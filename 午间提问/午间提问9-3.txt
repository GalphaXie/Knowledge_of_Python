1.什么是僵尸进程和孤儿进程,怎么避免僵尸进程?
	孤儿进程：父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作
	僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程
	避免僵尸进程的方法：
	1.fork两次用孙子进程去完成子进程的任务
	2.用wait()函数使父进程阻塞
	3.使用信号量，在signal handler中调用 waitpid，这样父进程不用阻塞


2.对不定长参数的理解？
	不定长参数有两种：*args和**kwargs;
	*args：是不定长参数，用来将参数打包成tuple给函数体调用
	**kwargs:是关键字参数，打包关键字参数成dict给函数体调用在定义函数的时候不确定要传入的参数个数会有多少个的时候就可以使用不定长参数作为形参

3.捕获异常机制，在 except中 return 后还会不会执行 finally 中的代码？怎么抛出自己处理不了的异常？
	会继续处理finally中的代码；
	用raise方法可以手动抛出异常

4.数据库备份怎么做，服务器挂了怎么办？
	备份数据库
	shell> mysqldump -h host -u root -p dbname >dbname_backup.sql
	恢复数据库
	shell> mysqladmin -h myhost -u root -p create dbname
	shell> mysqldump -h host -u root -p dbname < dbname_backup.sql

5.对cookie与session的了解？他们能单独用吗？
	Session采用的是在服务器端保持状态的方案，而Cookie采用的是在客户端保持状态的方案。但是禁用Cookie就不能得到Session。
	因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session。

6.lask中请求钩子的理解和应用
	请求钩子是通过装饰器的形式实现的，支持以下四种：
	1，before_first_request在处理第一个请求前运行
	2，before_request:在每次请求前运行
	3，after_request:如果没有未处理的异常抛出，在每次请求后运行
	4，teardown_request:即使有未处理的异常抛出，在每次请求后运行

7.跨站请求伪造和跨站请求保护的实现？
 
（1）一开始用户打开浏览器，访问受信任网站A，输入用户名和密码登陆请求登陆网站A。
（2）网站A验证用户信息，用户信息通过验证后，网站A产生Cookie信息并返回给浏览器。
（3）用户登陆网站A成功后，可以正常请求网站A。
（4）用户未退出网站A之前，在同一浏览器中，打开一个TAB访问网站B。
（5）网站B看到有人方式后，他会返回一些攻击性代码。
（6）浏览器在接受到这些攻击性代码后，促使用户不知情的情况下浏览器携带Cookie（包括sessionId）信息，请求网站A。这种请求有可能更新密码，添加用户什么的操作。
从上面CSRF攻击原理可以看出，要完成一次CSRF攻击，需要被攻击者完成两个步骤：
   1.登陆受信任网站A，并在本地生成COOKIE。
   2.在不登出A的情况下，访问危险网站 B。
如果不满足以上两个条件中的一个，就不会受到CSRF的攻击，以下情况可能会导致CSRF：
    1.登录了一个网站后，打开一个tab页面并访问另外的网站。
    2.关闭浏览器了后，本地的Cookie尚未过期，你上次的会话还没有已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）
解决办法：就是在表单中添加from.csrf_token





