### 1.常用的内置属性

| 内置属性  | 描述 | 应用场景 | 举例 | 所属对象 |
| --------- | ---- | -------- | ---- | --------- |
| `__new__` |      |          |      ||
| `__init__` | 初始化方法, 实例化对象的时候自动触发执行 | | ||
| `__repr__` | | | ||
| `__str__` | 一个类中定义了`__str__`方法，那么在打印 对象 时，默认输出该方法的返回值 | | ||
| `__del__` | 当前对象在内存中被释放时, 自动触发执行 | | Python是一门高级语言，程序员在使用时无需关心内存的分配和释放;<br />`__del__`的调用是由解释器在进行垃圾回收时自动触发执行的 ||
| `__file__` | 1.当运行py模块没有加路径的时候(即当前模块)那么结果是: 当前模块名;<br />2.如果运行的时候加了路径, 那么结果: 完整的模块名(包含前面的路径) | 当前模块名 | 查看系统包所在的位置, 类似`which`命令 ||
| `__name__` | | | ||
| `__import__` | | 动态加载模块 | 类比: import xx, xx.reload() ||
| `__doc__` | 文档信息(描述信息)的获取 | 类或者函数的主体功能介绍 | ||
| `__mro__` | 注意: 是类才有的属性, 而不是实例对象 | 多继承的顺序 | ||
| `type()` | | | ||
| `dir()` | | | ||
| `id()` | | | ||
| `__call__` | 实例对象后面加括号, 触发执行 | 注：`__init__`方法的执行是由创建对象触发的，即：`对象 = 类名()` ；而对于` __call__ `方法的执行是由对象后加括号触发的，即：`对象()` 或者 `类()()` | ||
| `__all__` | 1.常用在某个包的`__init_.py`文件中, 以序列形式存在, 里面保存是 各种 全局变量 | 类名 | 函数名 等的 字符串, 在通过 `from <model> import *` 这种方式导包的时候, 会自动加载这里列出的 元素; 否则没法导入.当然, 如果没有定义 `__all__` 那么则默认导入所有可以直接导入的 全局变量 \| 类名 \| 函数名等 | |
| `__iter__` |  |  |  | |
| `__next__` |  |  |  | |
| `__dict__` | 查看当前对象具有的属性(方法) |  | 可以通过该方法发现:<br />1.实例方法\|类方法\|静态方法都保存在类对象的内存空间中;<br />2.实例属性中针对`__xx`的私有属性是进行了`_类名__xx`的变量名重整<br />3.所以, 通过`实例对象名.__dict__`只能查看到实例对象的属性; 要查看实例对象的方法, 必须要通过`类名.__dict__`<br />4.注意这里的对象可以扩到到 模块, 事实上 `模块名.__dict__`也可以. | |
| `__class__` | 查看当前对象所属的类对象是那个. |  | 注意: `__main__`表示当前模块 | |
| `__module__` | 表示当前操作的对象所属模块 |  |  | |
| `__getitem__`<br />`__setitem_`<br />`__delitem__` | 用于索引操作, 如字典. <br />获取, 设置, 删除 | 可以自定义一个具有类似"字典"功能的对象 |  | |
| `__getslice__`<br />`__setslice_`<br />`__delslice__` | 用于分片操作, 如: 列表 | 可以自定义一个具有类似"列表"功能的对象 |  | |
|  |  |  |  | |
|  |  |  |  | |
|  |  |  |  | |

> - `__all__` 提供了暴露接口用的”白名单“。一些不以下划线开头的变量（比如从其他地方 import 到当前模块的成员）可以同样被排除出去。
>
> - 需要注意的是大部分情况下 `__all__` 都是一个 `list`，而不是 `tuple` 或者其他序列类型。如果写了其他类型的 `__all__`，如无意外 `pyflakes` 等 lint 工具会无法识别出。

```python
import os
import sys

__all__ = ["process_xxx"]  # 排除了 `os` 和 `sys`

def process_xxx():
    pass  # omit
```

注意:

> ### `定义 all 需要注意的地方`
>
> - 如上所述，`__all__` 应该是 `list` 类型的
> - 不应该动态生成 `__all__`，比如使用列表解析式。`__all__` 的作用就是定义公开接口，如果不以字面量的形式显式写出来，就失去意义了。
> - 即使有了 `__all__` 也不应该在非临时代码中使用 `from xxx import *` 语法，或者用元编程手段模拟 Ruby 的自动`import`。Python 不像 Ruby，没有 `Module`这种成员，模块就是命名空间隔离的执行者。如果打破了这一层，而且引入诸多动态因素，生产环境跑的代码就充满了不确定性，调试也会非常困难。
> - 按照 PEP8 建议的风格，`__all__` 应该写在所有 `import` 语句下面，和函数、常量等模块成员定义的上面。



`__getitem__、__setitem__、__delitem__`

- 用于索引操作，如字典。以上分别表示获取、设置、删除数据

```python
# -*- coding:utf-8 -*-

class Foo(object):

    def __getitem__(self, key):
        print('__getitem__', key)

    def __setitem__(self, key, value):
        print('__setitem__', key, value)

    def __delitem__(self, key):
        print('__delitem__', key)


obj = Foo()

result = obj['k1']      # 自动触发执行 __getitem__
obj['k2'] = 'laowang'   # 自动触发执行 __setitem__
del obj['k1']           # 自动触发执行 __delitem__
```



`__getslice__、__setslice__、__delslice__`

- 三个方法用于分片操作，如：列表

```python
# -*- coding:utf-8 -*-

class Foo(object):

    def __getslice__(self, i, j):
        print('__getslice__', i, j)

    def __setslice__(self, i, j, sequence):
        print('__setslice__', i, j)

    def __delslice__(self, i, j):
        print('__delslice__', i, j)

obj = Foo()

obj[-1:1]                   # 自动触发执行 __getslice__
obj[0:1] = [11,22,33,44]    # 自动触发执行 __setslice__
del obj[0:2]                # 自动触发执行 __delslice__
```





### 2.如何理解面向对象

- 1.相对于面向过程, 面向对象具有更高级的设计思路和理念;
- 2.来自对实际需求特征抽象出一个 模板 来更好的复用, 就是我们的类
- 3.将对象的静态特征作为属性; 动态特征作为方法封装到类的内部
- 4.面向对象除了上面的 封装, 还有 继承 和 多态两大特征;
- 5.继承大大提高了代码的复用
  - 单继承 | 多继承
  - 重写 | 拓展, `super()`
  - 私有属性|方法,  伪私有
  - `__mro__`
  - 继承的传递性
- 6.多态: 不同子类调用相同的父类方法, 得到不同的结果;
- 7.类属性|方法|静态方法(示例对象和类对象都不调用的方法)



#### enumerate() 枚举函数



**iter() 函**数

**next() 函数**



知识点补充:

`+=`  相当于 `extend()`

参考下面的错误代码:

```python
num = [11, 22]


def fun():
    num += [33, 44]   # 这里会报错, 虽然相当于 extend, 但是还是有不同; 未定义而使用变量
    # num.extend([33, 44])  # 这样则不会报错

print(num)
fun()
print(num)

```



进程号  ps aux

