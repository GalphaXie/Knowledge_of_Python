## 多任务--线程

### 1.相关概念

> 多任务: *操作系统可以同时运行多个任务*

#### 并发：
- 指的是任务数大于cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）
#### 并行：
- 指的是任务数小于等于cpu核数，即任务真的是一起执行的

#### 同步

- 同步就是协同步调，按预定的先后次序进行运行

#### 异步

- 略

#### 互斥锁

- 当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制
- 线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。
- 互斥锁为资源引入一个状态：锁定/非锁定
- 某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。



### 2.线程(Threading模块)

> - python的thread模块是比较底层的模块
> - threading模块是对thread做了一些包装的，可以更加方便的被使用



```python
import threading
import time


def func1():
    for i in range(5):
        print("这是一个线程测试函数func1")
        time.sleep(1)


def func2():
    for i in range(5):
        print("这是一个线程测试函数func2")
        time.sleep(1)


if __name__ == '__main__':
    print("-------主线程执行开始:{}-----------------".format(time.ctime()))
    t1 = threading.Thread(target=func1)
    t2 = threading.Thread(target=func2)
    t1.start()  #启动线程，即让线程开始执行
    t2.start()

    time.sleep(5)
    print("-------主线程执行结束:{}-----------------".format(time.ctime()))


########################################################
"""
笔记：
1.使用多线程并发的操作，花费时间要短很多
2.当调用start()时，才会真正的创建线程，并且开始执行
3.主线程会等待所有的子线程结束后才结束
4.threading.enumerate()  ： 是一个保存了 当前模块所有 线程的序列； 
"""
```



```python
import threading
import time


class MyThread(threading.Thread):
    """自定义的多线程类"""
    def run(self):
        for i in range(5):
            time.sleep(1)
            msg = "I'm " + self.name + " > " + str(i)  # name属性中保存的是当前线程的名字
            print(msg)
    
    def other_func(self):
        """在这里定义其他方法"""
        pass


def main():
    for i in range(5):
        t = MyThread()
        t.start()


if __name__ == '__main__':
    main()


########################################################
"""
笔记：
1.使用多线程并发的操作，花费时间要短很多
2.当调用start()时，才会真正的创建线程，并且开始执行

3.主线程会等待所有的子线程结束后才结束

4.一般工程中更多的是封装 MyThread(threading.Thread) , 重写 run() 方法来实现 多线程; 当执行 线程实例.start() 时，python解释器自动去实现每个线程实例都去执行 run()
    - 当线程的run()方法结束时该线程完成

5.多线程的执行顺序是不确定的。
    - 无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式

6.每一个线程可以指定名字， 如果不指定默认是： Thread-N


"""
```

> ​	多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。

### 3.线程核心概念

#### 3.1 (主|子)线程 生命周期

- 子线程: 
  - 调用 `Thread()`:  实例化的时候, 不会创建  子线程
  - 子线程 创建线程 并 开始执行: start()  ,  (内部会继续去调用 `run()`方法)
  - 当 target 的目标函数运行结束的时候, 子线程生命周期结束

- 主线程
  - 主线程最后结束
  - 主线程如果意外死掉, 子线程就死掉了

#### 3.2 共享全局变量及问题

- 在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据
- 缺点就是，线程是对全局变量随意遂改可能造成多线程之间对全局变量的混乱（即线程非安全）

- 如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确

```python
import threading
import time
import sys


g_num = 0
# count = 100000
count = int(sys.argv[1])

def _sum_1(count):
    global g_num
    for i in range(count):
        g_num += 1
        # time.sleep(0.0001)


def _sum_2(count):
    global g_num
    for i in range(count):
        g_num += 1
        # time.sleep(0.0001)


if __name__ == '__main__':
    t1 = threading.Thread(target=_sum_1, args=(count, ))
    t2 = threading.Thread(target=_sum_2, args=(count, ))

    t1.start()
    t2.start()

    while len(threading.enumerate()) != 1:
        time.sleep(1)

    print("主函数执行结束: {}".format(time.ctime()))
    print("当前g_num的值：{}".format(g_num))
```



#### 3.3 上锁解锁过程

- 当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。
- 每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。
- 线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。



```python
import threading
import time
import sys


g_num = 0
# count = 100000
count = int(sys.argv[1])

# 创建锁
mutex = threading.Lock()
# # 锁定
# mutex.acquire()
# # 释放
# mutex.release()


def _sum_1(count):
    global g_num
    for i in range(count):
        mutex.acquire()  # 上锁
        g_num += 1
        mutex.release()  # 解锁

    print("---—_sun_1---g_num=%d" % g_num)


def _sum_2(count):
    global g_num
    for i in range(count):
        mutex.acquire()  # 上锁
        g_num += 1
        mutex.release()  # 解锁

    print("---—_sun_2---g_num=%d" % g_num)


if __name__ == '__main__':
    t1 = threading.Thread(target=_sum_1, args=(count, ))
    t2 = threading.Thread(target=_sum_2, args=(count, ))

    t1.start()
    t2.start()

    while len(threading.enumerate()) != 1:
        time.sleep(1)

    print("当前g_num的值：{}".format(g_num))
```



#### 3.4 锁的优劣

锁的好处：

- 确保了某段关键代码只能由一个线程从头到尾完整地执行

锁的坏处：

- 阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了
- 由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁
  - 死锁: 在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。

#### 3.5 避免死锁

- 程序设计时要尽量避免（银行家算法）
- 添加超时时间等

```python
import threading
import time
import sys


g_num = 0
# count = 100000
try:
    count = int(sys.argv[1])
except Exception as e:
    count = 100000

class MyThread1(threading.Thread):
    def run(self):
        # 对mutexA上锁
        # mutexA.acquire()
        mutexA.acquire()

        # mutexA上锁后，延时1秒，等待另外那个线程 把mutexB上锁
        print(self.name+'----do1---up----')
        time.sleep(1)

        # 此时会堵塞，因为这个mutexB已经被另外的线程抢先上锁了
        mutexB.acquire()
        print(self.name+'----do1---down----')
        mutexB.release()

        # 对mutexA解锁
        mutexA.release()


class MyThread2(threading.Thread):
    def run(self):
        # 对mutexB上锁
        mutexB.acquire()

        # mutexB上锁后，延时1秒，等待另外那个线程 把mutexA上锁
        print(self.name+'----do2---up----')
        time.sleep(1)

        # 此时会堵塞，因为这个mutexA已经被另外的线程抢先上锁了
        mutexA.acquire()
        print(self.name+'----do2---down----')
        mutexA.release()

        # 对mutexB解锁
        mutexB.release()


mutexA = threading.Lock()
mutexB = threading.Lock()


if __name__ == '__main__':
    t1 = MyThread1()
    t2 = MyThread2()
    t1.start()
    t2.start()

    while len(threading.enumerate()) != 1:
        time.sleep(1)

    print("当前g_num的值：{}".format(g_num))
```













## 多任务 -- 进程

1.主进程死掉,子进程可以存活;  而 子线程死掉 , 子线程一般也死掉.  ==> 进程比线程要稳定;

2.多线程 和 多进程 中 子线程或子进程 彼此的执行顺序都是不确定的. 这是他们的共同点.

3.获取进程 pid , 使用python的 `os` 模块, `os.getpid()` 或 `os.getppid()`

4.命令:  `top`  `htop`  `ps -aux`







## 其他补充:

- 僵尸进程
- 孤儿进程
- 时间片轮转
- 写时拷贝