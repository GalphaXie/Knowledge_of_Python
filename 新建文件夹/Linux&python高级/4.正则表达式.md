### 1.正则表达式概述

> - 不同编程语言中一般都有正则表达式
> - 正则表达式是一种更高级的操作 字符串或文本的方法

### 2.Python中提供`re`模块实现

```python
#coding=utf-8

# 导入re模块
import re

# 如果匹配成功则返回匹配到的对象, 该对象支持 group方法; 否则返回None
result = re.match(正则表达式,要匹配的字符串)

if result:
	result.group()
```

#### 2.2 `group` 方法的补充

- 用于 从一个匹配到的正则表达式对象中提取 匹配到的字符串;
- `group()`没有传递参数的时候, 表示提取 匹配到的完整的字符;
- `group(数字)` 表示 提取 匹配到的字符串中 进行分组后的 对应分组 中匹配到的值;
  - 数字1 表示提取 分组1 中的值; 当然 数字0 也表示 分组1 中的值;
  - 数字2  表示提取 分组2 中的值, 其他的 依次类推. 

### 3.匹配单个字符

| 字符 | 功能                                                         |
| ---- | ------------------------------------------------------------ |
| .    | 匹配任意1个字符（除了\n）                                    |
| [ ]  | 匹配[ ]中枚举的字符                                          |
| \d   | 匹配数字，即0-9                                              |
| \D   | 匹配非数字，即不是数字                                       |
| \s   | 匹配空白，即 空格，tab键, 制表符等                           |
| \S   | 匹配非空白                                                   |
| \w   | 匹配单词字符，即a-z、A-Z、0-9、_   还包括一些其他Unicode编码字符, 如中文 |
| \W   | 匹配非单词字符                                               |

- 举例: 
  -   `[0-36-9]`
  - `\d+` 

### 4.匹配多个字符

| 字符  | 功能                                                    |
| ----- | ------------------------------------------------------- |
| *     | 匹配前一个字符出现0次或者无限次，即可有可无             |
| +     | 匹配前一个字符出现1次或者无限次，即至少有1次            |
| ?     | 匹配前一个字符出现1次或者0次，即要么有1次，要么没有     |
| {m}   | 匹配前一个字符出现m次                                   |
| {m,n} | 匹配前一个字符出现从m到n次;  **注意: {}内部不能有空格** |

#### 4.1 匹配一个邮箱

**规则: 1.@符号前面4-20位普通字符; 2.邮箱域名163或126或QQ三种**

```python
re.match(r"\w{4,20}@(163|126)\.com$", email_str)
```

- 1.需要对 `.` 这样的特殊字符转义;
- **2.`|` 表示 或 的意思, 类比`[]` 一个是进行多个字符的枚举, 一个是进行单个字符的枚举. 且 `|` 常常和 `()` 进行连用, 表示分组的含义.**
- **3.最好加上结尾的 `$`表示 截止符**

### 5.匹配分组

| 字符         | 功能                             |
| ------------ | -------------------------------- |
| \|           | 匹配左右任意一个表达式           |
| (ab)         | 将括号中字符作为一个分组         |
| `\num`       | 引用分组num匹配到的字符串        |
| `(?P<name>)` | 分组起别名                       |
| (?P=name)    | 引用别名为name分组匹配到的字符串 |

#### 5.1 提取区号和电话号码

```python
ret = re.match(r"(\d+)-(\d+)", "021-12345678").group()
ret = re.match(r"([^-]*-(\d+))", "021-12345678").group()
```

#### 5.2 提取`html`页面中的一些标签(可能不规则)

```python
#coding=utf-8

import re

labels = ["<html><h1>www.sina.cn</h1></html>", "<html><h1>www.sina.cn</h2></html>"]

for label in labels:
    ret = re.match(r"<(\w*)><(\w*)>.*</\2></\1>", label)
    if ret:
        print("%s 是符合要求的标签" % ret.group())
    else:
        print("%s 不符合要求" % label)
```

`(?P<name>) 和 (?P=name)`

```python
#coding=utf-8

import re

ret = re.match(r"<(?P<name1>\w*)><(?P<name2>\w*)>.*</(?P=name2)></(?P=name1)>", "<html><h1>www.sina.cn</h1></html>")
ret.group()

ret = re.match(r"<(?P<name1>\w*)><(?P<name2>\w*)>.*</(?P=name2)></(?P=name1)>", "<html><h1>www.sina.cn</h2></html>")
ret.group()
```

- 注意: `?P` 中的 P 要大写

### 6.re模块的高级用法

#### 6.1 search  

- 类同 `match` , 区别在于 `search` 不用从 目标字符串 第一个字符开始和正则表达式匹配.
- 返回的是 `匹配到的对象`, 需要用 `group()` 去提取.

#### 6.2 findall

- 类同 `search` . 不过可以同时  从目标字符串中 匹配多个 符合正则表达式的 提取字符串
- 注意: **返回值是一个列表, 内部的元素是 目标字符串中匹配到的子字符串**

#### 6.3 sub 将匹配到的数据进行替换 -- 强大的数据清洗工具

- 不同于之前学习的三个匹配方式, 之前一般都传递两个参数即可(正则表达式, 目标字符串)
- `sub(正则表达式, 如果匹配成功后要被替换为的目标, 目标字符串)`
- **(第二个参数)可以有两种不同的使用方式:**
  - 1.替换成字符串;
  - 2.传递函数的引用 (如果是这种方式, 那么相当于将匹配到的数据作为该位置引用函数的参数, 可以在该函数内部实现一些列的复杂的操作, 追踪返回值是 匹配到的要替换成的对象)
- 注意返回值:
  - 返回值是: 整个字符串, 改变的仅仅是匹配成功的位置为期望替换成的字符串

**方法一:**

```python
#coding=utf-8
import re

ret = re.sub(r"\d+", '998', "python = 997")
print(ret)
```

> ```python
> # 运行结果:
> python = 998
> ```

**方法二:**

```python
#coding=utf-8
import re

def add(temp):
    strNum = temp.group()
    num = int(strNum) + 1
    return str(num)

ret = re.sub(r"\d+", add, "python = 997")
print(ret)

ret = re.sub(r"\d+", add, "python = 99")
print(ret)
```

> ```python
> # 运行结果:
> python = 998
> python = 100
> ```

**案例: 从招聘网站上提取某职位的干净的文本信息**

```python
re.sub(r"<[^>]*>?|&nbsp;|\n", "", html_str)
```

- 浏览器读取前端代码的时候, 默认将多个空行或者空格当作一个空格来对待, 那么要实现多个空格, 就最后采用了 `&nbsp;*个数`  .

#### 6.4 split 根据匹配进行切割字符串，并返回一个列表

```python
#coding=utf-8
import re

ret = re.split(r":| ","info:xiaoZhang 33 shandong")
print(ret)
```

> ```python
> # 运行结果
> ['info', 'xiaoZhang', '33', 'shandong']
> ```

### 7.python的贪婪和非贪婪

**Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符；**

**非贪婪则相反，总是尝试匹配尽可能少的字符。**

**在"*","?","+","{m,n}"后面加上？，使贪婪变成非贪婪。**



```python
>>> s="This is a number 234-235-22-423"
>>> r=re.match(".+(\d+-\d+-\d+-\d+)",s)
>>> r.group(1)
'4-235-22-423'

>>> re.match(r"aa(\d+)","aa2343ddd").group(1)
'2343'
>>> re.match(r"aa(\d+?)","aa2343ddd").group(1)
'2'
>>> re.match(r"aa(\d+)ddd","aa2343ddd").group(1) 
'2343'
>>> re.match(r"aa(\d+?)ddd","aa2343ddd").group(1)
'2343'
>>>
```

### 8.r的作用

`Python中字符串前面加上 r 表示原生字符串`，与大多数编程语言相同，`正则表达式里使用"\"作为转义字符`，这就可能造成反斜杠困扰。假如你需要匹配文本中的字符"\"，那么使用编程语言表示的正则表达式里将需要4个反斜杠"\\"：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。

Python里的原生字符串很好地解决了这个问题，有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。

**解释说明:**

- 作为操作系统来说, `\a` 等字符是有特殊含义的, 需要对`\` 进行转义, 
- 作为正则表达式来说, `\` 也是其中的一个特殊字符, 要表示`\` 也需要在python中进行祝转义. 
- 即, 在python的正则表达式中`\\\\` 才能表示 操作系统里面的`\\`, 而操作系统去解释的时候也会再次转义成 `\` 来表示 诸如 `\a` 这样的对象. 

### 9.一些补充

#### 9.1 两个妙用:

- [^]  取反
- sub() 函数

#### 9.2 多义符号

- `^`
  - 匹配字符串的起始位置
  - 取反
- `?`
  - 匹配 0 或 1 个前面的字符;
  - 非贪婪匹配
- `()`
  - 分组(原子提取)

#### 9.3 正则表达式看起来简单, 用好不容易, 用熟练需要多练习和积累.