**标配:** ORM框架 +  缓存               

### 传统的常规解决性能的方案:

- 1.web层, 动态页面**静态化**技术, 超过一定时间的文章生成静态HTML文件;
- 2.数据据进行**分库分表**, 按年拆表;

##### 补充--常见的概念:

- ActiveRecord  :  活动记录, 其实就是 ORM, 每一个模型类对应关系型数据库的一个表, 每一个对象对应一行记录.
- CPU 的 IO  Wait  低于 5%
- schema 架构模式

#### ORM缓存的基本理念

- 以**减少数据库服务器磁盘IO为最终目的**，而不是减少发送到数据库的SQL条数。实际上使用ORM，会显著增加SQL条数，有时候会成倍增加SQL。

- 数据库schema设计的取向是**尽量设计 细颗粒度 的表**，表和表之间用外键关联，颗粒度越细，缓存对象的单位越小，缓存的应用场景越广泛

- 尽量避免多表关联查询，尽量拆成多个表单独的主键查询，尽量多制造 n + 1 条查询，不要害怕“臭名昭著”的 n + 1 问题，实际上 n + 1 才能有效利用ORM缓存
  - 就是 查到 主数据,通过该数据再查n条从数据, 就有了 1+n ;   
  - 而基于主键的查询可以直接利用对象缓存。可以通过  **懒查询来解决**

#### 缓存存在的问题

对于**强事务性**的场景，如何**保证缓存和db的一致性**呢？在并发修改缓存的过程中，又该如何确保缓存被正确修改呢？



#### redis缓存

##### 一、缓存在系统中用来做什么

\1. 少量数据存储，高速读写访问。通过数据全部in-momery 的方式来保证高速访问，同时提供数据落地的功能，实际这正是Redis最主要的适用场景。

\2. 海量数据存储，分布式系统支持，数据一致性保证，方便的集群节点添加/删除。Redis3.0以后开始支持集群，实现了半自动化的数据分片，不过需要smart-client的支持。

##### 二、从不同的角度来详细介绍redis

**网络模型**：Redis使用单线程的IO复用模型，自己封装了一个简单的AeEvent事件处理框架，主要实现了epoll、kqueue和select，对于单纯只有IO操作来说，单线程可以将速度优势发挥到最大，但是Redis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU计算过程中，整个IO调度都是被阻塞住的。

**内存管理**：Redis使用现场申请内存的方式来存储数据，并且很少使用free-list等方式来优化内存分配，会在一定程度上存在内存碎片，Redis跟据存储命令参数，会把带过期时间的数据单独存放在一起，并把它们称为临时数据，非临时数据是永远不会被剔除的，即便物理内存不够，导致swap也不会剔除任何非临时数据（但会尝试剔除部分临时数据），这点上Redis更适合作为存储而不是cache。

**数据一致性问题**：在一致性问题上，个人感觉redis没有memcached实现的好，Memcached提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题。 Redis没有提供cas 命令，并不能保证这点，不过Redis提供了事务的功能，可以保证一串命令的原子性，中间不会被任何操作打断。

**支持的KEY类型**：Redis除key/value之外，还支持list,set,sorted set,hash等众多数据结构，提供了KEYS进行枚举操作，但不能在线上使用，如果需要枚举线上数据，Redis提供了工具可以直接扫描其dump文件，枚举出所有数据，Redis还同时提供了持久化和复制等功能。

**客户端支持**：redis官方提供了丰富的客户端支持，包括了绝大多数编程语言的客户端，比如我此次测试就选择了官方推荐了Java客户端Jedis.里面提供了丰富的接口、方法使得开发人员无需关系内部的数据分片、读取数据的路由等，只需简单的调用即可，非常方便。

**数据复制**：从2.8开始，Slave会周期性（每秒一次）发起一个Ack确认复制流（replication stream）被处理进度

**读写分离**：redis支持读写分离，而且使用简单，只需在配置文件中把redis读服务器和写服务器进行配置，多个服务器使用逗号分开如下：

**水平动态扩展**：历时三年之久，终于等来了期待已由的Redis 3.0。新版本主要是实现了Cluster的功能，增删集群节点后会自动的进行数据迁移。实现 Redis 集群在线重配置的核心就是将槽从一个节点移动到另一个节点的能力。因为一个哈希槽实际上就是一些键的集合， 所以 Redis 集群在重哈希（rehash）时真正要做的，就是将一些键从一个节点移动到另一个节点。

**数据淘汰策略**：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。

---



**缓存穿透**

- 缓存命中率

- 一般网站经常会缓存用户搜索的结果，如果数据库查询不到，是不会做缓存的。但如果频繁查这个空关键字，会导致每次请求都直接查询数据库了。

- 如果把查询不到的空结果，也给缓存起来，这样下次同样的请求就可以直接返回null了，即可以避免当查询的值为空时引起的缓存穿透。

  可以单独设置个缓存区域存储空值，对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。

**缓存雪崩**

前面不是用加锁排队方式就解决了吗？其实加锁排队只是为了减轻数据库的压力，本质上并没有提高系统吞吐量。

假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。导致的结果是用户等待超时，这是非常不优化的体验。

这种行为本质上是把多线程的Web服务器，在此时给变成单线程处理了，会导致大量的阻塞。对于系统资源也是一种浪费，因缓存重建而阻塞的线程本可以处理更多请求的。



[参考文章](http://www.cnblogs.com/mushroom/p/4199701.html)

---

线程安全 问题?

