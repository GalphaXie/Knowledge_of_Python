## shell 笔记 2019-03-02 21:36

### 0.shell介绍

- 0.自动化可以通过两种方式来实现:  **工具** 和 **脚本**

- 1.常见的脚本有两种
  - shell脚本
  - 其他脚本, 诸如python脚本等
- 2.shell 是一个  **命令解释器** , shell是位于应用程序和操作系统之间的有效命令翻译工具.
- 3.shell分为两大类
  - 1.图形化的shell , 如我们常说的操作系统的桌面
  - 2.命令行的shell
    - win 系统下的 cmd
    - Linux 系统下的 shell   (sh  bash  ksh ...)
      - 注: **最原始的shell是 `sh` , 目前各大`*uinx`平台的shell是bash, 它新增了很多功能**  . 所以在shell脚本中 推荐使用 `#!/bin/bash`代替`#!/bin/sh`
  - 3.查看系统shell类型:  `echo $SHELL`
  - 4.查看当前系统环境支持的shell  :  `cat /etc/shells`
  - 5.shell手工执行的时候有一个重要的特点: **逐行输入命令, 逐行解释执行**  (解释性语言都是如此)

## 1. shell脚本的基础知识

#### 0.概念

- 常用编辑工具 vim vi
- 命名: **见名知义**

#### 1.注释

##### 1.1单行注释

​	除了 **首行** 加`#`不是注释外, 其他在行首加`#`均表示此行是单行注释

##### 1.2多行注释

​	实现方式有两种:

- 方法一

```shell
:<<!
...  #这里表示注释掉的内容
!
```

- 方法二

```shell
:<<字符
...  #这里表示注释掉的内容
字符
```

#### 2.脚本执行(三种方式)

##### 2.1强烈推荐的方式: 写完整的路径名

`/bin/bash /path/script-name.sh ` (更推荐) 或 `bash /path/script-name.sh`

##### 2.2当前路径下执行脚本

`path/to/script-name.sh` 或 `./script-name.sh` 

**注意:** 要修改文件的可执行权限 `chmod +x script-name.sh`

##### 2.3点 执行

`source script-name.sh`  或 `. script-name.sh`

> 执行说明：
>
> 1、脚本文件本身没有可执行权限或者脚本首行没有命令解释器时使用的方法，我们推荐用bash执行。
>
> 使用频率：☆☆☆☆☆
>
> 2、脚本文件具有可执行权限时使用。
>
> 使用频率：☆☆☆☆
>
> 3、使用source或者.点号，加载shell脚本文件内容，使shell脚本内容环境和当前用户环境一致。
>
> 使用频率：☆☆☆
>
> 使用场景：环境一致性

#### 3.脚本开发规范

- 1.命名要见名知义, 脚本后缀是 `.sh`

- 2.脚本首行是且必须是`#!/bin/bash`
- 3.第二行开始一般先写脚本的描述信息:
  - 3.1脚本名称, 功能, 版本, 作者, 联系信息等
  - 3.2注释 **不推荐中文**, 避免不同的操作系统出现中文乱码的问题
- 4.脚本的执行也是从上到下依次执行, 但是可以通过 `&`灵活的使其中 **部分阻塞式的命令在后台执行**

- 5.代码书写规范
  - 5.1 成对内容一次写出防止遗漏, 比如 `()`等
  - 5.2 `[  ]`中括号内部的 **两端**要有空格
  - 5.3 内部流程控制语句一次性书写完, 再添加内容.
  - 5.4通过缩进提高代码的 **可读性**, 即该有空格的地方要有空格
    - *注: 比较奇葩, 往往有些地方没有空格, 会因为python代码的规范来误用空格,比如在给变量的赋值的时候就容易犯这样的错误*

#### 4.变量

##### 0.变量

- 变量名  (不变的部分)
- 变量值  (可变的部分)

通常提到 **变量** 指的是 **变量名**

##### 1.本地变量

- 注: *在当前系统的**某个环境下**才能生效的变量, 作用范围小*
- 本地变量包含两种
  - 普通变量
  - **命令变量**  (必须掌握)

**普通变量** 的定义方式(三种)

- 1.方式一:  `变量名=变量值`

  - **重点:** 变量值必须是一个整体，中间没有特殊字符
  - **注意:**  **等号**两边都不能有空格

- 2.方式二: `变量名='变量值'`

  - **重点:** "所见即所得"

  - 这里是 `单引号`不是 `反引号`

- 3.方式三: `变量名="变量值"`

  - **重点:**如果变量值范围内, 有可以解析的变量A, 那么首先解析变量A, 将A的结果和其他内容组合成一个 **整体** , 重新赋值给变量B

- 4.习惯:  ==数字不加引号, 其他默认加双引号==

**命令变量** 定义有两种方式:  **(熟练)** 

- 1.方式一: 变量名=<code>&#96;</code>命令<code>&#96;</code>
-  2.方式二: 变量名=$(命令)
- *注意点:  这里==等号==两边都不能有空格*

##### 2.全局变量

- 注: 在当前系统所有环境都能生效得变量
- **查看全局变量:**  `env` 命令查看系统的所有环境变量

**定义全局变量**

```shell
方法一
	变量名=变量值
	export 变量名
方法二
	export 变量名=变量值
```

显然通过上面定义方式, 我们更加倾向选用 方法二

**变量查看和取消**

```shell
查看变量
	方式一
		$变量名
	方式二
		"$变量名"
	方式三
		${变量名}
		频率较高, 在作为一个被双引号已经包裹的命令中使用
	方式四
		"${变量名}"
		标准用法, 推荐用法

取消变量
	unset 变量名
```

##### shell内置变量

- **注:** 无需我们定义就可以直接来使用的变量

**和脚本文件有关**

| 符号 | 意义                                                         |
| ---- | ------------------------------------------------------------ |
| $0   | 获取当前执行的shell脚本文件名，包括脚本路径                  |
| $n   | 获取当前执行的shell脚本的第n个参数值，n=1..9，当n为0时表示脚本的文件名，如果n大于9就要用大       括号括起来${10} |
| $#   | 获取当前shell命令行中参数的总个数                            |
| $?   | 获取执行上一个指令的返回值(0为**成功** , 非0为**失败**)      |

**字符串精确截取相关**

`格式: ${变量名:起始位置:截取长度}`

```shell
#示例代码:
${file:0:5}		从第1个字符开始，截取5个字符
${file::5}			从第1个字符开始，截取5个字符
${file:5:5}		从第6个字符开始，截取5个字符
${file:5}			从第6个字符开始，截取后面所有的字符
${file:0-5}		从倒数第5个字符开始，截取后面所有的字符
${file:0-6:3}		从倒数第6个字符开始，截取之后的3个字符
```

**默认值相关**

> 1.格式: `${变量名:-默认值}`
>
> 场景:
>
> - if 变量a 有值,  then 输出 变量a 的值
> - 否则, 就输出 默认值

```shell
#!/bin/bash
#套餐选择演示: 如果用户指定了套餐n那么就输出n, 否则一律输出套餐1
a="$1"
echo "您选择的套餐是: ${a:-1}"
```

> 2.格式: `${变量名+默认值}`
>
> 场景:
>
> - 无论变量a是否有内容, 都输出默认值
> - 注:  如果不给参数, 那么默认不显示的 ,这个和上面不同

```shell
#!/bin/bash
# 无论输入法定结婚年龄是多少岁, 一律输出法定结婚年龄(男性)22岁
a="$1"
echo "国家法定结婚年龄(男性)是${a+22}岁"
```



#### 5.SHELL 进阶

##### 1. 表达式

**1.1 测试语句形式**

**A: test 条件表达式**

**B: [ 条件表达式 ]**   ==更常用==

格式注意:

- 1.上述两种方式作用完全一样, 后者更加常用
- 2.后者需要注意 `[]`的 内部两端与条件表达式之间至少有一个空格
- 3.test跟 [] 意思一样
- 4.**条件成立, 状态返回值是0, 条件不成立, 状态返回值是1**

**1.2 条件表达式**

> **逻辑表达式**
>
> - 逻辑表示一般用于判断多个条件之间的依赖关系
>
> - 两种:  &&  和 ||

**"夫唱妇随"**

```shell
1. &&
命令1 && 命令2
如果命令1执行成功, 那么执行命令2
如果命令1执行失败, 那么也不再执行命令2
```

**"对着干"**

```shell
1. ||
命令1 || 命令2
如果命令1执行成功, 那么不执行命令2
如果命令1执行失败, 那么执行命令2
```

> **文件表达式**
>
> -f  判断输入内容是否是一个文件

```shell
#!/bin/bash
# description: 判断xx是否是一个文件
[ -f test.sh ] && echo "是一个文件"
[ -f test.sh ] || echo "不是一个文件"
```

