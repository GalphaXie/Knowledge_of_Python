### 1.udp 与 tcp的不同：

- 1.1 通俗来说，udp模式类似“写信”，只发送出去，并不确定对方是否成功接收。tcp类似于“打电话”，先拨通对方的号码确定对方在接听，再收发数据。

- 1.2  对比：

  |      角度      | udp  | tcp  |
  | :----------: | :--: | :--: |
  |     安全性      |  低   |  高   |
  |     传输效率     |  高   |  低   |
  |     面向连接     |  否   |  是   |
  | 是否有服务器、客户端概念 |  否   |  是   |

### 2. 网络通信三要素：

​	IP、端口(port)、协议

- 2.1 IP地址：用来在网络中标记一台电脑，不允许重复；

- 2.2 网络地址的分类：Ａ、Ｂ、Ｃ、Ｄ、Ｅ。我们常用的是Ｃ类地址，每类地址尤其对应的ＩＰ范围。这里说的都是针对ＩＰｖ４而言。

- 2.3私有ＩＰ：

  > 10.0.0.0～10.255.255.255
  >
  > 172.16.0.0～172.31.255.255
  >
  > 192.168.0.0～192.168.255.255

- 2.4 注意：IP地址127．0．0．1~127．255．255．255用于回路测试，如：127.0.0.1可以代表本机IP地址，用`http://127.0.0.1`就可以测试本机中配置的Web服务器。


### 3.tcp注意事项：

- tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器
- tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机
- tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的
- 当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信
- 当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务
- listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的
- 关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。
- 关闭accept返回的套接字意味着这个客户端已经服务完毕
- 当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线

### 4.socket --- 套接字

​        Socket又称"套接字"，应用程序通常通过"套接字"向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。

​        语法格式：

```
socket.socket([family[, type[, proto]]])
```

- family: 套接字家族可以使AF_UNIX或者AF_INET，一般后者使用更多。


- type: 套接字类型可以根据是面向连接的还是非连接分为`SOCK_STREAM`或`SOCK_DGRAM ，分别对应tcp和udp。`


- protocol: 一般不填默认为0.

### 5.udp和tcp在细节方面的一些不同：

- 1.创建套接字socket的时候，参数不同，udp -- SOCK_DGRAM, tcp -- SOCK_STREAM
- 2.接收信息：udp -- recvfrom方法，返回的是 ```数据和地址``` ；tcp -- recv方法，返回的是```数据```
- 3.发送信息：udp -- sendto方法，需要传入```数据和对方的地址```作为参数；而tcp -- send方法，只需要传入```数据```作为参数
- 4.通信过程不同：upd -- 1>创建套接字;2>绑定本地信息，这一步可以省略；3>收发信息；4>关闭套接字；
- 4.通信过程不同：
  - tcp -- 客户端：1>创建套接字；2>.链接服务器；3>收发信息；4>关闭套接字；
  - tcp -- 服务端：1>创建套接字；3>绑定本地信息；3>监听将套接字从默认的主动修改为被动，listen()；4>等待客户端的链接,accept()；5>收发信息；6>关闭套接字.
- 5.堵塞与解堵塞：
  - 5.1 udp通过recvfrom完成堵塞/解堵塞；
  - 5.2 tcp的客户端通过recv堵塞/解堵塞；
  - 5.3 tcp的服务器通过accept、recv堵塞/解堵塞：
    - 服务器的accept需要客户端的connect来解堵塞
    - 服务器recv需要客户端的send来解堵塞
    - recv还可能因为客户端调用close()导致解堵塞，且recv返回的是None。--注：这两者同时成立作为判断"不需要服务"的条件。