

## 一 python基础

### 1.数据结构--可变类型和不可变类型

对**<u>可变类型</u>**进行修改, 其 **<u>内存地址不变,但是其内部的内容发生改变</u>**

- 主要是: 字典 \ 列表

对**<u>不可变类型</u>**进行修改, 其 **<u>内存地址变化,即引用发生改变,等同赋值操作</u>**

- 主要是: 数字  字符  元组



### 2.赋值|浅拷贝|深拷贝

#### 一、赋值--"旧瓶装旧酒"

在python中,对象的赋值就是简单的对象`引用`, 这点和C++等语言不同.如:

```python
In[2]: a = [1, 2, 'hello', ['python', 'C++']]
In[3]: b = a
In[4]: a is b
Out[4]: True
In[5]: b is a
Out[5]: True
In[6]: id(a)
Out[6]: 139705399858952
In[7]: id(b)
Out[7]: 139705399858952
# 总结: 
1.通过 is 判断它们的内存地址相同;
2.通过 id() 来查看两者的内存地址也相同.

In [1]: a = 3                                     
In [2]: b = 3                                     
In [3]: a is b                                     Out[3]: True
In [4]: id(a)                                     Out[4]: 10919488
In [5]: id(b)                                     Out[5]: 10919488
# 通过这个例子,很容易说明:
1. python 中 不可变类型 在内存中只有一份, 不论如何嵌套,其id()值相同.
```

​	在上述情况下,`a`和`b`是一样的,它们指向同一片内存地址,b不过是a的别名,是引用.

​	赋值操作(包括对象作为参数、返回值)不会开辟新的内存空间,只是复制了对象的引用. 也就是说 <u>除了 b 这个名字之外, 没有其它的内存开销</u>. 修改了 a 或 b , 另外一个 b 或 a 同样跟着受影响.

​	python的赋值操作还有一个通俗的理解: **<u>先在内存中创建等号右边的对象, 然后把等号左边的变量作为标签贴在右边对象上,是为引用.</u>**

​	**赋值操作注意:** 还要注意作用域,在不同作用域可以创建同样的 "值"; 但是这个"值"的内存空间是不同的.

#### 二、浅拷贝(shallow copy)--"新瓶装旧酒"

​	浅拷贝会创建新对象, 其对象非原来对象的引用, 而是原来对象内第一层对象的引用.

 	<u>通俗理解:拷贝了引用,并没有拷贝内容;产生了新对象,但是里面的内容还是同一份</u>

​	浅拷贝 三种形式: **<u>切片操作</u>**  **<u>工厂函数</u>**  **<u>copy模块中的copy函数</u>**. 比如上述列表a;

 - 切片操作:   c = a[:]
 - 工程函数:  c = list(a)
 - copy函数: c = copy.copy(a)

```python
In[8]: c = a[:]
In[9]: c is a
Out[9]: False
In[10]: id(a)
Out[10]: 139705399858952
In[11]: id(c)
Out[11]: 139705390811656
In[12]: [id(x) for x in a]
Out[12]: [10919424, 10919456, 139705494889056, 139705399859272]
In[13]: [id(x) for x in c]
Out[13]: [10919424, 10919456, 139705494889056, 139705399859272]
# 总结:
1. b 不在(is)是 a ,也不指向(id())同一个内存空间;
2. 但是 [id(x) for x in a] 和 [id(x) for x in c] 结果相同. 说明: a 和 c 内部的元素对象指向的是同一片内存地址.
    
In[14]: id(a[3][0])
Out[14]: 139705495480280
In[15]: id(c[3][0])
Out[15]: 139705495480280
In[16]: a[3][0]
Out[16]: 'python'
In[17]: a[3].append('java')
In[18]: b
Out[18]: [1, 2, 'hello', ['python', 'C++', 'java']]
# 总结:
1. 关于浅copy的理解,个人以为用内层和外层来区分更容易理解.通俗来说,浅拷贝就是只修改了最外层的引用, 使得元素最外层的地址变化,但是对原来元素的内层地址和引用均未做修改.
2. 把这里最外层列表中的每一个元素(包括列表元素)都看作一个'坑', 每个'坑'再指向一个具体的 对象. 这就是'引用'.

In[19]: a[1] = 10
In[20]: a
Out[20]: [1, 10, 'hello', ['python', 'C++', 'java']]
In[21]: c
Out[21]: [1, 2, 'hello', ['python', 'C++', 'java']]
In[22]: b
Out[22]: [1, 10, 'hello', ['python', 'C++', 'java']]
 
# 事实上,这里就比较绕; 思路还是要从 是否修改引用 来思考.
1. python中一直都是先在内存中有对象,然后再对对象有引用.
2. [17]修改的是 嵌套列表内部的元素,并未对最里层列表本身的 内存地址 产生影响, 所以 a 和 c 指向的内层列表仍然是同一个对象,所以其中一个修改,两者同时发生改变.
3. [19]修改的是 不可变类型, 相当于 指向了新的引用;所以 a 和 c 不同.
```

#### 三、深拷贝(deep copy)--"新瓶装新酒"

​	深拷贝 只有一种形式 , copy模块中的 `deepcopy()` 函数

​	深拷贝拷贝了对象的所有元素,包括多层嵌套的元素.  因此,它的时间和空间开销要高.

​	深拷贝拷贝出来的对象根本就是一个全新的对象,不再于原来的对象有任何的关联.

​	深拷贝类似没有 `出口的递归拷贝`

#### 四、拷贝注意点

​	**<u>对于非容器类型, 如数字 , 字符 , 以及其它的"原子"类型, 没有拷贝一说, 产生的都是原对象的引用.</u>**

​	**<u>如果元组变量值包含原子类型对象, 即使采用了深拷贝,也只能得到浅拷贝.</u>**

(上面这句话, 没有理解...)



#### 五、最直观的还是补充高级中学习的图.

##### ---待补"坑"---







deepcopy()  通过引用计数







### 3.python基本数据结构

#### 3.1 字典

##### 3.1.1 按照字典的v值进行排序

`sorted(d.items(),  key=lambda x:x[1] )`

- items 取出的是 类字典的键值对 对象
- keys 取出的是 类列表对象
- 注意排序后的返回值是一个list，而原字典中的kv对被转换为了list中的元组。

```python
# 案例
alist = [{'name':'a','age':20}, {'name':'b','age':30}, {'name':'c','age':25}]
def sort_by_age(alist):
    return sorted(alist, key=lambda x:x['age'], reverse=True)
```

补充1: `sorted()函数`: 

**sorted(iterable,key,reverse)，sorted一共有iterable,key,reverse这三个参数**。

- iterable表示可以迭代的对象，例如可以是dict.items()、dict.keys()等
- key是一个函数，用来选取参与比较的元素
- reverse则是用来指定排序是倒序还是顺序，reverse=true则是倒序，reverse=false时则是顺序，默认是reverse=false。

补充2: `lanbda函数` [链接:lanbda函数](#8.1 匿名函数 lambda)

##### 3.1.2 字典和json的区别

​	字典是一种数据结构, json是一种数据的表现形式, 字典的key值只能是能hash的就行, json的值必须是字符串.

参考CSDN博文: [json和python中字典的区别和联系](https://blog.csdn.net/py_tester/article/details/79032077)



#### 3.2 列表

##### 3.2.1 列表的常见操作

1)增加

- `li.insert(index, 数据): 在制定的位置插入数据(指定位置前有空元素会自动补位)`
  - 这个说法不严谨,其实如果用 **负索引插入** 到初始位置之间有空位也会自动补位
- `li.apend(数据): 在列表的末尾追加数据(最常用的方法)`
- `li.extend(Iterable): 将可迭代对象中的元素追加到列表`
  - extend和 `+=` 的区别

2)取值和修改

- 取值: 列表名[index] : 根据下标来取值
- 修改: 列表名[index] = 数据 : 修改指定索引的数据

3)删除

- del 列表名[index] : 删除指定索引的数据
- del 列表名: 删除指定列表, 和 clear() 区别
- 列表名.remove(数据): 删除第一个出现的数据
- 列表名.pop() : 删除末尾数据,返回值: 返回被删除的元素
- 列表名.pop(index) : 删除指定索引的数据,返回值: 返回被删除的元素
- 列表名.clear()  : 清空整个列表的元素

4)排序

- 列表名.sort() : 升序(小到大)
- 列表名.sort(reverse=True) : 降序(大到小)
- 列表名.reverse() : 逆序, 反转

5)统计相关

- len(列表名) : 计算列表长度
- 列表名.count(数据) : 数据在列表中出现的次数
- 列表名.index(数据): 数据在列表中首次出现时的索引, 没有查到会报错.
- 数据  in  列表  

6)循环遍历

- while循环
- for循环

7)切片

- 正向切片,反向切片
- 注意"左闭右开"

##### 3.2.2 列表的注意事项

```python
索引超出会报错:IndexError
但是切片超出不会报错,返回 空[]
插入超出也不会报错, 自动从两端往中间补位
```

##### 3.2.3 列表生成式 | 元组生成器 | 字典推导式 | 三元运算符 | 逻辑操作符

```python
# 平时注意积累写法和场景,有时候灵活运用可以大大简化代码
```

##### 3.2.2 列表思考题:

-  1.实现list去重的思路

```python
1. 集合
2. 遍历
```

- 2.代码题

```python
def extendList(val, list=[]):
    list.append(val)
    return list

list1 = extendList(10)
list2 = extendList(123, [])
list3 = extendList('a')

print(list1)
print(list2)
print(list3)
------------------
结果:
    [10, 'a']
    [123]
    [10, 'a']
解释:
    许多人会错误的认为 list1 应该等于 [10] 以及 list3 应该等于 ["a"]。认为 list 的参数会在 extendList 每次被调用的时候会被设置成它的默认值 []。 尽管如此，实际发生的事情是，新的默认列表仅仅只在函数被定义时创建一次。随后当 extendList 没有被指定的列表参数调用的时候，其使用的是同一个列表。这就是为什么当函数被定义的时候，表达式是用默认参数被计算，而不是它被调用的时候。 因此，list1 和 list3 是操作的相同的列表。而 ````list2是操作的它创建的独立的列表（通过传递它自己的空列表作为list``` 参数的值）。 extendList 函数的定义可以做如下修改，但，当没有新的 list 参数被指定的时候，会总是开始一个新列表，这更加可能是一直期望的行为。 def extendList(val, list=None): if list is None: list = [] list.append(val) return list 使用这个改进的实现，输出将是： list1 = [10] list2 = [123] list3 = ["a"]
参考链接:http://www.maiziedu.com/article/8260/ 
解释2:
    很多人都会误认为list1=[10],list3=['a'],因为他们以为每次extendList被调用时，列表参数的默认值都将被设置为[].但实际上的情况是，新的默认列表只在函数被定义的那一刻创建一次。当extendList被没有指定特定参数list调用时，这组list的值随后将被使用。这是因为带有默认参数的表达式在函数被定义的时候被计算，不是在调用的时候被计算。
因此list1和list3是在同一个默认列表上进行操作（计算）的。而list2是在一个分离的列表上进行操作（计算）的。（通过传递一个自有的空列表作为列表参数的数值）。
```

​	**新的默认列表只有在函数被定义的那一刻创建一次. 当func 被没有指定list 的情况下调用时,这组list的值随后将被使用. 这是因为带有默认参数的表达式在函数被定义的时候被计算,不是在调用的时候被计算.**

​	拓展资料: [深度拓展,来自sf网站](https://segmentfault.com/a/1190000006265256)



#### 3.3 元组

- 单个元素的元组 `(1, )`

#### 3.4 字符串

3.4.1 反转字符串

字符串:`str.[::-1]`





#### 3.5 数字(int)

- 小数 保留指定位数的小数 `round(float, 要保留的位数)`



#### 3.6 集合

**支持 union(联合), intersection(交), difference(差), sysmmetric_difference(对称差集)等数学运算.**

- 去重  `set()`
- 交集: `a&b `   共有的部分
- 并集: `a|b`  总共的部分
- 差集: `a-b` 或 `b-a` 另一个集合中没有的部分  (前者有后者没有,即在第一个集合中,不在第二个集合中)
- 对称差集: `a^b`  (在a, b中, 但是不会同时出现在二者中...)



#### 3.7 布尔类型









### 4.文件读写操作--大文件读写|生成器读取



### 5.python 常见标准库

#### 5.1 random库 -- 生成随机数

random.random()    0-1之间随机浮点数

random.uniform(a, b)   [a, b]之间浮点数

random.randint(a, b)  [a, b]之间的整数

random.randrange(a, b, step)  [a, b) 中 以 step 为基数 随机取数

random.choice(sequence)  从特定序列中随机取一个 元素

补充: 打乱一个排序的列表

- `random.shuffle(alist)`



#### 5.2 datetime库 -- 日期操作



#### 5.3 time库



### 6.日志功能



### 7. python性能提升 | 内存管理与垃圾回收机制 | 作用域 | 命名空间 | PEP8规范

#### 7.1 性能提升:

- 1.多进程,充分利用机器的多核性能;
- 2.对性能影响较大的部分代码,可以使用C或C++编写
- 3.对于IO阻塞造成的性能影响,可以使用IO多路复用来解决
  - 链接:  [IO多路复用机制](https://blog.csdn.net/chewbee/article/details/78108223)
- 4.尽量使用Python的内建函数
- 5.尽量使用局部变量

#### 7.2 内存管理与垃圾回收机制

##### 7.2.1 python 的内存管理机制及调优手段

**内存管理机制: 引用计数, 垃圾回收, 内存池**

- 1.引用计数
- 2.标记清除
  - 1.引用计数
  - 2.标记清除
  - 3.分代回收
  - 
- 3.内存池

**调优手段:**

- 1.手动垃圾回收 `__del__`
- 2.调高垃圾回收阈值
- 3.避免循环引用(手动解循环引用和弱引用)

##### 7.2.2 内存泄漏是什么? 如何避免?

- 指由于疏忽或者错误造成程序未能释放已经不再使用的内存情况.(失去对内存的控制,造成内存浪费)
- `__del__()`方法的对象间的循环引用是导致内存泄漏的主凶;
  - 解决方法也是: 不使用的时候,正确 del object 删除
- 辅助python模块:
  -  `gc` 查看不能回收对象的详细信息;
  - `sys.getrefcount(obj)` 来获取对象的引用计数,并根据返回值是否为0 来判断是否内存泄漏.

#### 7.3 作用域

​	python中,一个变量的作用域总是由在代码中被赋值的地方所决定.当python遇到一个变量的时候,会按照下列的顺序进行搜索:

**本地作用域(Local)** --->  **当前作用域被嵌入的本地作用域(Enclosing locals)** --->  **全局\模块作用域(Global)** ---> **内置作用域(Built-in)**

- 参考链接: [Python基本语法_变量作用域LEGB](https://blog.csdn.net/jmilk/article/details/50244817)
- 个人理解:
  -  Local就是内层函数的空间;
  - Enclosing locals 就是 外层函数的空间(闭包)
  - Global  就是 模块 全局
  - Built-in  就是 python解释器自带的内置函数和属性空间.

#### 7.4 命名空间

​	在python中所有的名字都存在一个空间中, 它们在该空间中存在和被操作----这就是命名空间

​	它就像是一个盒子,每一个变量名字都对应装着一个对象.当查询变量的时候,会从该盒子里面寻找相应的对象.

#### 7.5 PEP8规范

链接: [PEP8的python风格格式规范（中文版）](http://http//zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/)



### 8.关于编码问题



### 9.序列化与反序列化





## 二 python高级

### 1.Liunx | 虚拟环境 | 



### 2.网络通信

大牛文章必看: 

[IP地址的分配原理](https://blog.csdn.net/qzcsu/article/details/72859431)

[TCP的三次握手与四次挥手（详解+动图）](https://blog.csdn.net/qzcsu/article/details/72861891)

```latex
为什么建立连接是三次握手，关闭连接确是四次挥手呢？

建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 
而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。
```







### 1.三大法器|递归

#### 迭代器

#### 生成器

#### 装饰器



```python
# 面向切面编程 -- 切面需求的场景
Aspect Oriented Programming(AOP)，面向切面编程，是一个比较热门的话题。AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。
# 需求场景案例:
- 插入日志
- 性能测试
- 事务处理
- 缓存
- 权限的校验
```











#### 递归



### 1.数据库基础

##### 关系型数据库核心元素

- 数据行(记录)
- 数据列(字段)
- 数据表(数据行的集合)
- 数据库(数据表的集合)

##### 关系型数据库的主要产品：

- oracle：在以前的大型项目中使用,银行,电信等项目
- mysql：web时代使用最广泛的关系型数据库
- ms sql server：在微软的项目中使用
- sqlite：轻量级数据库，主要应用在移动平台

##### RDBMS

- Relational Database Management System

数据库的命令:

##### 主从配置优势:

- 实现读写分离
- 可以实现集群(灵活扩展)
- 相互之间可以 实现 **'备份'**

















### 2.Mysql数据库

#### 2.1 原理 优势 应用场景

- 适合用于关系特别复杂的数据查询场景的 **应用场景**.

#### 2.2 开启,创建库,创建表

- 分为服务端和客户端
- 命令

```mysql
# 安装 服务端 , 客户端
# 启动 关闭 重启
# 创建数据库,创建数据表,创建字段, 创建记录
# 查看创建过程, 
insert into 
update set ... where...
select * from ...
delete from ... where ...
# 回复和备份:
mysqldump -uroot -p db_name > db_copy_name.sql;   # 使用: mysqldump
mysql -uroot -p db_refleshed_name < db_copy_name.sql;  # 使用: mysql
```







#### 2.3 增删改查

#### 2.4 容灾备份和恢复



### 3.Redis数据库

#### 3.1 原理 优势 应用场景 

- 持久化存储
- 内存型数据库
- 缓存,速度快,自动过期
  - 是不是完全贴合 'session'?
  - 以及做高并发的场景.
- redis性能最受影响的就是 **联网的时候**

#### 3.2 创建库,创建表
```python
redis-server  # 启动服务器
redis-cli  # 启动客户端
ping
select 1
keys *
type 键
flushdb  清空当前db数据库
flushall 清空数据库
```

#### 3.3 增删改查

- Redis原生指令参考 <http://redisdoc.com/index.html>
- [中文网站的命令文档](http://redis.cn/commands.html#generic)
- Redis python客户端 方法参考 <http://redis-py.readthedocs.io/en/latest/#indices-and-tables>

#### 3.4 容灾备份和恢复



### 4.Mangodb数据库

#### 4.1 原理 优势 应用场景 

#### 4.2 创建库,创建表

#### 4.3 增删改查

#### 4.4 容灾备份和恢复



### 5.ORM | 数据库原理 | 数据库调优 | 数据库迁移

#### 5.1ORM

##### 5.1.1 概念

- **ORM** 全拼`Object-Relation Mapping`.
- 中文意为 **对象-关系映射**.
- 主要实现模型对象到关系数据库数据的映射.
  - 比如：把数据库表中每条记录映射为一个模型对象

##### 5.1.2 ORM图解

![img](./img_advanced/ORM.png)

##### 5.1.3 优点 :

- 只需要面向对象编程, 不需要面向数据库编写代码.
  - 不用编写各种数据库的`sql语句`.
  - 对数据库的操作都转化成对类属性和方法的操作.
- 实现了数据模型与数据库的解耦, 屏蔽了不同数据库操作上的差异.
  - 不在关注用的是`mysql`、`oracle`...等.
  - 通过简单的配置就可以轻松更换数据库, 而不需要修改代码.

##### 5.1.2 缺点 :

- 相比较直接使用SQL语句操作数据库,有性能损失.
- 根据对象的操作转换成SQL语句,根据查询的结果转化成对象, 在映射过程中有性能损失.





#### 数据库迁移










### 5.虚拟环境

5.1 在ubuntu中安装虚拟环境管理工具(配置环境变量)

```python
sudo pip install virtualenv
sudo pip install virtualenvwrapper
# 安装完虚拟环境后，如果提示找不到 mkvirtualenv 命令，须配置环境变量：

# 1、创建目录用来存放虚拟环境
mkdir 
$HOME/.virtualenvs

# 2、打开~/.bashrc文件，并添加如下：
export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh

# 3、运行
source ~/.bashrc

```

5.2 创建项目虚拟环境(python解释器)

```python
# 默认是python2
mkvirtualenv 项目虚拟环境名称
# 如果安装python3解释器的 项目虚拟环境
mkvirtualenv -p python3 项目虚拟环境名称
```

小提示:

- **创建虚拟环境需要联网**
- 创建成功后, 会自动工作在这个虚拟环境上
- 工作在虚拟环境上, 提示符最前面会出现 “虚拟环境名称”
- 虚拟环境安装python包的时候, 不要加 `sudo` , 否则达不到隔离.

5.3`使用(查看)` | `退出` | `删除`虚拟环境

```python
# 使用查看(workon不是worken; 该命令可以在任意目录下输入)
workon 两次tab键  (然后选择一个需要使用的虚拟环境)
workon 项目虚拟环境名
# 退出
deactivate   （敲除deac后可以自动补全）
# 删除
先退出：deactivate
再删除：rmvirtualenv 项目虚拟环境名
```

5.4 如何在虚拟环境中安装工具包

提示 : 工具包安装的位置 :

python2版本下：
​	~/.virtualenvs/项目虚拟环境名/lib/python2.7/site-packages/
python3版本下：
​	~/.virtualenvs/项目虚拟环境名/lib/python3.5/site-packages

```python
# pip
pip install  # 安装依赖包   虚拟环境中不需要权限(千万注意,如果使用sudo则安装在全局)
pip uninstall  # 卸载依赖包
pip list  # 查看已安装的依赖包
pip freeze  # 冻结当前环境的依赖包
```

5.5 虚拟环境是独立的,你可以看成是一块儿独立的环境,该环境中存在硬链接的`python`解释器; 然后 `workon`该环境后切换 项目的目录 来运行各个项目.

5.6 pycharm 配置虚拟环境

![pycharm 配置虚拟环境](.\img_advanced\pycharm配置虚拟环境.png "pycharm配置虚拟环境")

5.7 辨析(虚拟环境, python包, 以及依赖环境)

- 遇到的问题: 想在虚拟环境中安装 `opencv` , 但是opencv 有很多底层依赖
- 解决: 安装还是要通过 `sudo apt-get ...` 来安装.

### 6.git和GitHub

#### 6.1 使用GIt管理源代码

<u>注: 1.本地提交:add(添加到暂存区)->commit(提交到工作区)->push(提交到远程仓库)</u>

##### 6.1.1 本地提交

```python
# 1.初始化git
cd [项目目录]
git init
# 2.配置当前项目git提交信息(可省略此步，如不配置则使用全局配置)
git config user.name xxx
git config user.email XX@xxx.com
# 3.添加忽略文件
touch .gitignore  (注意不要写成 .ignore)
# 3.1 在忽略文件中,设置忽略文件内容(后续可以根据需要继续添加)
.idea
*.py[cod]
# 4.添加所有文件到暂存区
git add .
# 5.提交本地仓库并填写注释
git commit -m"第一次提交"
# 6.让pycharm管理当前项目
File -> setting -> Version Control -> ...
```

![pycharm管理当前项目](.\img_advanced\pycharm配置git.png)

##### 6.1.2 远程提交

<u>在github或者码云等平台创建项目,创建完成后将已有项目上传到码云</u>

上传项目到github

方式1：使用命令行的形式将项目上传到码云

```python
cd 项目根目录
git remote add origin 仓库地址
git push -u origin master
```

方式2：使用Pycharm将项目上传到码云

- 拷贝地址:  从remote拷贝 https或者ssh地址
- 添加远程地址到pycharm
  - `VCS -> Git -> Remotes`
- 输入远程地址
  - orign   
  - URL
- 输入github或者码云等账号和密码,点击`ok`
- 选择菜单中的 `VCS` -> `Git` -> `Push`
- Push 成功后Pycharm 弹出提示 `Push successful`



git的一些其它指令

```python
# 回滚到上一个版本
git reset --hard HEAD~1
# 查看所有提交版本记录
git reflog
# 回到指定版本
git reset --hard 提交id

# 查看本地 暂存区|工作区的状态?????(待核实)
git status
```

其它:

- 难在:  冲突的处理, 一般谁冲突谁解决;
- 最好的习惯是在remote创建项目然后 pull 到本地.

6.1.3 关于实际开发中分支切换等问题--来自[公众号]整理

- 从远程仓储clone: `git clone git@github.com:GalphaXie/Review_Python.git` 或 `git clone https://github.com/GalphaXie/Review_Python.git`
- 下载后的项目默认是在 `master`分支, 一定要进行分支切换 `git checkout develop`
- 这个时候需要添加 **A功能**, 那么应该从`master`分支再创建一个分支 : `git branch feature-A`,并切换到该分支: `git checkout feature-A` 
  - 可以合并命令为:  `git checkout -b feature-A develop` 

- 提交到暂存区: `git add feature-A`     (类似本地的文件的 `Ctrl + s` 的操作)
- 提交到工作区: `git commit -m 'add feature-A'`
- 进行**分支合并**,但是这**之前一定要做**的一步是: `git pull origin develop` 取回远程库的更新,来防止冲突(因为很多人在develop上面提交代码) 
- 然后再切换到自己的分支: `git checkout feature-A`, 然后 用 `rebase命令` 合并新的更新到自己目前的工作分支.
- 最后: `git merge --no-ff feature-A`
- 最最后: `git push origin develop`



### 7. Linux 命令 | vim 命令

[Linux命令大全](https://blog.csdn.net/DefaultTest/article/details/80721021)

[编辑器之神：VIM 常用命令整理](https://blog.csdn.net/DefaultTest/article/details/80755709)



### 8.函数

#### 8.1 匿名函数 lambda

语法: `lambda [arg1 [,arg2,.....argn]]:expression`  即:   **关键字  参数 : 语句**

所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。

- lambda 只是一个表达式，函数体比 def 简单很多。
- lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。
- lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。
- 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。

参考链接: [菜鸟教程 Python3 函数](http://www.runoob.com/python3/python3-function.html)



### 9.面向对象



### 10.进程 线程 协程

#### 10.1概念辨析

异步

同步

阻塞

非阻塞

并行

并发

I/O密集型 

CPU密集型



## 三 Python web 框架要点

### 1.web开发基本概念:

#### 1.1**web框架的定义** ：

- <u>协助开发者快速进行**web程序**开发的一套功能代码块。</u>

#### 1.2**框架的优势**： <u>避免重复造轮子</u>

- 降低开发难度， 提高开发效率
- 稳定性和可扩展性强
- 通俗理解：成熟的web框架对**数据流，安全性**等进行了很好的通用支持，使得开发者可以更好的专注于 **业务逻辑的实现**。

#### 1.3web开发各部分的构成

![web应用处理流程](img_django/web_processing_sequence.png)

- web开发(开发框架)  是基于 **应用层(HTTP)** 开发.
  - 前端通过 实现  **HTTP请求** 来和后端通信
  - 后端程序又分为 **服务器程序** + **框架程序**
    - 服务器
      - 处理的是 HTTP请求报文
    - 框架程序
      - 接收并解析HTTP请求，获取具体的请求信息
      - 处理本次HTTP请求，即完成本次请求的业务逻辑处理
      - 构造并返回处理结果——HTTP响应
    - ==WSIG== 协议 **(待完善)**
    - WSGI 协议 规定:  框架处理请求和响应对象, 中间还要提供中间件处理.

### 2.web框架学习方法

- 1.如何搭建工程程序
  - 工程的组建
    - 如何创建应用实例, 如 flask=Flask()
    - 单个脚本 还是  拆分成多个目录?
  - 工程的配置
    - 配置文件、配置类、==?(flask还有一种)== 等配置方式的选择
  - 路由定义
    - Flask是以装饰器的形式实现;
    - Django是以**项目urls**文件和**应用urls**文件共同实现
  - 视图函数定义
    - 函数视图、类视图
    - 是否需要必传参数(如django中的request是必传参数)
    - 固定写法
- 2.如何获取请求数据（操作request对象）
  - 身份认证, 权限校验, 限流校验
  - 请求头参数的获取
  - 请求路径参数的获取
  - 请求体的获取(包括Form表单数据)的获取
- 3.如何构造响应数据（构造response对象）
  - 响应头
  - 响应体
  - 状态码
- 4.如何使用中间层
  - 请求钩子
  - 中间件
- 5.框架提供的其他功能组件的使用
  - 数据库
  - 模板
  - admin



## 三 Flask基础

### 1.web基础

- 

#### 1.3跨站请求伪造(CSRF : Cross-site request forgery)

```python
1.CSRF原理分析:
- 1.1 HTTP是无状态协议,所以需要会话保持手段, 比如用 cookies;
- 1.2 CSRF的场景是: 正常网站A,  黑客网站B, 客户端(浏览器).
- 1.3: 跨站请求伪造: 存在两个网站A(trusted)和网站B(hacked),用户C.用户C登陆交易网站A,正常登陆之后,网站A返回响应并在响应中添加cookie,在未退出网站A登陆的情况下又登陆了黑客网站B.网站B以诱导用户C点击的方式发送了向网站A交易请求url,这个请求会带着用户C浏览器刚才生成的cookie,去进行在网站A上的转出交易.给用户造成损失.   
```

09  CSRF原理分析
​		跨站请求伪造: 存在两个网站A(trusted)和网站B(hacked),用户C.用户C登陆交易网站A,正常登陆之后,网站A返回响应并在响应中添加cookie,
​		在未退出网站A登陆的情况下又登陆了黑客网站B.网站B以诱导用户C点击的方式发送了向网站A交易请求url,这个请求会带着用户C浏览器刚才生成的cookie,
​		去进行在网站A上的转出交易.给用户造成损失.

10  解决CSRF攻击
​	1. 在原生form表单提交的时候,设置变量代码块{{ csrf_token()  }}来接收每次服务器返回的不同随机值,并且把这个标签设置为隐藏:type="hidden"
​	2. 在返回响应的时候设置 cookies 中的部分内容为相同随机出来的 csrf_token.
​	3. 在每次提交的时候,服务端从cokies中取出request.cookies.get("csrf_token"),并从表单中 request.form.get("csrf_token")取出,进行校验.
​	设置方式:
​		bytes.decode(base64.b64encode(os.urandom(48)))	

	进行CSRF之后:
		1. 网站B提交的表单没法获取到用户C的csrf_token,只能获取csrf_token标签的结构和自己的csrf_token;
		可以利用用户C浏览器中的csrf_token,但是也没法获取到用户C的cookies(浏览器的同源策略)
	
	Flask 自带CSRFProtect 只需要在前端Form表单中设置   {{ form.csrf_token() }} 即可
	
	还有一个要注意的点: flask默认是存到 session 中的.所以,这个和在session中要设置   secret_key 而不是在 cookie中设置 对应上了.

#### 1.4 ORM的简单介绍



#### 1.5 扩展

- **WSGI 工具箱采用 Werkzeug（路由模块），模板引擎则使用 Jinja2。**
- 7行代码实现 Flask 简单的应用.
- 视图常用逻辑

  - 1.返回json数据;
  - 2.重定向;
  - 3.自定义状态码;
- (url)转换器  基类:  BaseConverter

  - to_url 方法
  - to_python方法
- 异常捕获

  - 主动抛出:   HTTP异常 abort(500)方法
  - 捕获错误:  @errorhandler(code_or_exception) 装饰器
- 请求钩子 -- (Django中 中间件)

  - before_first_request

    - 在处理第一个请求前执行

  - before_request

    - 在每次请求前执行

  - after_request

    - 在请求完成后, 响应返回之前执行.可以对响应进一步处理.
    - 前提: 没有抛出错误

  - teardown_request
- Flask框架

![Flask框架](./img_flask/Flask框架.png)

  - Flask有两大核心：Werkzeug和Jinja2

      - Werkzeug是一个遵循WSGI协议的python函数库
          - Rule类
            - 用来构造不同的URL模式的对象，路由URL规则
        - Map类
          - 存储所有的URL规则和一些配置参数
        - BaseConverter的子类
          - 负责定义匹配规则
        - MapAdapter类
          - 负责协调Rule做具体的匹配的工作

- 获取请求参数

  - request 就是flask中代表当前请求的 request 对象，其中一个请求上下文变量(理解成全局变量，在视图函数中直接使用可以取到当前本次请求)
  - 常用属性:  data, form, args, cookies, headers, method, url, files...

- 状态保持

  - Cookie
    - Cookie基于域名安全，不同域名的Cookie是不能互相访问的
  - Session

- 上下文

  - 请求上下文:  
    - request  
    - session
  - 应用上下文:  
    - current_app
    - g    
      - g 作为 flask 程序全局的一个临时变量, 每次请求都会刷新.
  - 两者区别:
    - 请求上下文：保存了客户端和服务器交互的数据
    - 应用上下文：flask 应用程序运行过程中，保存的一些配置信息，比如程序名、数据库连接、应用信息等

#### 1.6 蓝图

- 1.解决的问题: 在 项目中模块增多的时候, 需要'解耦', 而直接解耦的话会存在 '循环导入' 的问题,这个时候就有了 蓝图. 蓝图就是 '缩小版'的 flask_app,  可以有自己的独立的模板,模块等.
- 2.相当于 '中间人 和 小弟 ';  可以类比Django中的  app包.
- 3.注意: 在蓝图注册路由的时候,并未把蓝图后的url添加到map中,是在 蓝图的 注册 后添加的.









## 四 Flask项目







## 五 Djaong基础

### Django介绍

![django_logo](img_django/django_logo.png)

#### 1. 简介

Django，**发音为[`dʒæŋɡəʊ]**，是用python语言写的开源web开发框架，并遵循MVC设计。劳伦斯出版集团为了开发以新闻内容为主的网站，而开发出来了这个框架，于2005年7月在BSD许可证下发布。这个名称来源于比利时的爵士音乐家DjangoReinhardt，他是一个吉普赛人，主要以演奏吉它为主，还演奏过小提琴等。**由于Django在近年来的迅速发展，应用越来越广泛，被著名IT开发杂志SDTimes评选为2013SDTimes100，位列"API、库和框架"分类第6位，被认为是该领域的佼佼者。**

![django信念](img_django/django_belief.png)

Django的**主要目的是简便、快速的开发数据库驱动的网站。**它强调代码复用，多个组件可以很方便的以"插件"形式服务于整个框架，Django有许多功能强大的第三方插件，你甚至可以很方便的开发出自己的工具包。这使得Django具有很强的可扩展性。它还强调快速开发和DRY(DoNotRepeatYourself)原则。

#### 2. 特点

##### 1） 重量级框架

对比Flask框架，Django原生提供了众多的功能组件，让开发更简便快速。

- 提供项目工程管理的自动化脚本工具(shell)  ==具体使用,补充链接==
  - 命令行创建工程目录
  - 提供shell
  - 类比 Flask中的 **script 扩展**  ==忘记==
- 数据库ORM支持（对象关系映射，英语：Object Relational Mapping）
- 模板
- 表单
- Admin管理站点
  - 一旦创建完成数据库, 那么就可以自动进行管理后台的 增删改查.
- 文件管理
  - 前端上传文件, 后端自动可以保存到 服务器 指定的位置 ==疑问==
- 认证权限
- session机制
- 缓存
- 等等

##### 2）MVT模式

有一种程序设计模式叫**MVC**，其核心思想是**分工、解耦，让不同的代码块之间降低耦合，增强代码的可扩展性和可移植性，实现向后兼容**。

> MVC的全拼为**Model-View-Controller**，最早由TrygveReenskaug在1978年提出，是施乐帕罗奥多研究中心(Xerox PARC)在20世纪80年代为程序语言Smalltalk发明的一种软件设计模式，是为了将传统的输入（input）、处理（processing）、输出（output）任务运用到图形化用户交互模型中而设计的。随着标准输入输出设备的出现，开发人员只需要将精力集中在业务逻辑的分析与实现上。后来被推荐为Oracle旗下Sun公司Java EE平台的设计模式，并且受到越来越多的使用ColdFusion和PHP的开发者的欢迎。现在虽然不再使用原来的分工方式，但是这种分工的思想被沿用下来，广泛应用于软件工程中，是一种典型并且应用广泛的软件架构模式。后来，MVC的思想被应用在了Ｗeb开发方面，被称为Ｗeb MVC框架。

#### MVC模式说明

![mvc](img_django/mvc.png)

- M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。
- V全拼为View，用于封装结果，生成页面展示的html内容。
- C全拼为Controller，用于接收请求，处理业务逻辑，与Model和View交互，返回结果。

#### Django的MVT

![mvt](img_django/mvt.png)

- M全拼为Model，与MVC中的M功能相同，负责和数据库交互，进行数据处理。
- V全拼为View，与MVC中的C功能相同，接收请求，进行业务处理，返回应答。
- T全拼为Template，与MVC中的V功能相同，负责封装构造要返回的html。

**注：差异就在于黑线黑箭头标识出来的部分**

#### 3. Django学习资料

- [官方网站](https://www.djangoproject.com/)
- [Github源码](https://github.com/django/django)
- [1.11版英文文档](https://docs.djangoproject.com/en/1.11/)
- [1.11版中文文档](https://yiyibooks.cn/xx/Django_1.11.6/index.html)
- [Django Book 教程](http://djangobook.com/)
- [Tange With Django 教程](http://www.tangowithdjango.com/book17/)









接口设计思路



#### restful风格

**综合上面的解释，RESTful架构就是：**

- **每一个URL代表一种资源；**
- **客户端和服务器之间，传递这种资源的某种表现层；**
- **客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。**

```txt
自己的理解:
1. 具象状态转化协议
2. 通过请求的四个方法(POST, GET, PUT, PATCH, DELETE)  来获取资源
3. 主要是url,将之前的查询参数变成资源路径. url中使用名词, 且使用复数
```





#### 使用drf实现视图时的思路

- 先以视图为主
- 分析视图实现的具体逻辑
- 思考逻辑中有哪些可以使用 drf 框架提供的工具来复用代码
  - 序列化
    - 参数校验
    - 保存
    - 序列化返回数据
  - 视图扩展类  子类视图
    - 视图整个实现的流程  可以复用的代码







## 六 Django项目

### 1. 环境创建和工程创建注意事项

#### 1.1 环境创建和工程创建

- 1.推荐 `1.XX` 版本的 **Django** ,  在虚拟环境中通过 `-p` 选项来指定对应的 解释器版本, 如果不指定可能会默认是python2的解释器.

- 2.推荐通过命令行的模式创建 `django` 工程, 然后再在 **pycharm** 中进行适当配置(如果不能自动找到新创建的django虚拟环境,则需要我们手动添加虚拟环境;  对于通过manage.py启动来说还需要我们添加必要的启动参数 `runserver` 这些).

  - 2.1 解释: 如果直接通过 pycharm 创建工程 可能会自动添加其它额外参数, 可能导致在 线上命令行部署时候出现其它的一些问题.
  - 2.2 补充：我们在pycharm打开django工程的时候, 发现会自动创建 `db.splite3` 数据库, 这是 **django** 默认数据库.  在我们配置指定的数据库之后, 该文件会被django自动删除.

- 3.**manage.py** 不仅是功能模块,  还是 **Django** 提供的脚本文件的模块, 可以用来提供 **django命令模式来操作django项目**, 类似 Flask 框架的 Script 模块. 

- 4.单个django工程 | 单个app 分别包括:

  - 4.1 **settings.py**  **urls.py**  **uwsgi**  **\_\_init\_\_.py**  和平行的 **manage.py** , **db.splite3**
  - 4.2 **migrations文件夹**  **\_\_init\_\_.py**  **admin.py(后台管理站点)**  **apps.py(关于该子应用的一些配置信息)**  **models.py**  **tests.py(子引用的单元测试)**  **views.py**  和 我们需要自己创建的 **serializers.py**  **urls.py**

  ![django项目目录结构](./img_django/django_pro_dir.png)

  - 与项目同名的目录，此处为demo。
  - **settings.py** 是项目的整体配置文件。
  - **urls.py** 是项目的URL配置文件。
  - **wsgi.py** 是项目与WSGI兼容的Web服务器入口。
  - **manage.py** 是项目管理文件，通过它管理项目。

- 5.运行 **开发服务器**

  `python manage.py runserver ip:端口`  其中,  `ip:port`可省略, 则默认: **127.0.0.1:8000 **

  `python manage.py runserver` 运行 服务器

  - django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。
  - 按ctrl+c停止服务器。

#### 1.2 创建子应用

​	在Web应用中，通常有一些业务功能模块是在不同的项目中都可以复用的，故在开发中通常将工程项目拆分为不同的子功能模块，各功能模块间可以保持相对的独立，在其他工程项目中需要用到某个特定功能模块时，可以将该模块代码整体复制过去，达到复用。

在Flask框架中也有类似子功能应用模块的概念，即蓝图Blueprint。

**Django的视图编写是放在子应用中的。**

##### 通过命令行创建子应用

 `python manage.py startapp 子应用名称`   备注: 可能需要创建目录如apps等(看需求)

- **admin.py** 文件跟网站的后台管理站点配置相关。
- **apps.py** 文件用于配置当前子应用的相关信息。
  - 注: **子应用的配置文件**,和在`settings.py`中注册APP联系起来, **app_name.apps.XxConfig**
  - 类比 **Flask** 中的 **蓝图注册**, 将独立的蓝图模块和项目配置关联起来.
- **migrations** 目录用于存放数据库迁移历史文件夹。
- **models.py** 文件用户保存数据库模型类。  ==整理常见的套路==
- **tests.py** 文件用于开发测试用例，编写单元测试。
- **views.py** 文件用于编写Web应用视图。

![app子应用的目录结构](./img_django/app_dir.png)

#### 1.3 注册APP

创建出来的子应用目录文件虽然被放到了工程项目目录中，但是django工程并不能立即直接使用该子应用，需要注册安装后才能使用。

在工程配置文件settings.py中，**INSTALLED_APPS**项保存了工程中已经注册安装的子应用，初始工程中的INSTALLED_APPS如下：

![初始INSTALLED_APPS](./img_django/initial_installed_apps.png)

- **注册安装一个子应用的方法，即是将子应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。**
- 从 **1.8 版本**之后, 注册路由就不在直接使用 **子应用的名字** 而是 代替成 **子应用名.apps.配置类的名字**
- 注意: 项目中, 往往有**多个 APP 应用**, 常常会创建**apps**目录, 将各个应用添加到apps目录下, 则需要在 **settings.py** 文件中配置 `sys.path.insert(0, os.path.join(BASE_DIR, "apps"))` 

#### 1.4 APP应用配置

在每个应用目录中都包含了apps.py文件，用于保存该应用的相关信息。

在创建应用时，Django会向apps.py文件中写入一个该应用的配置类，如

```python
from django.apps import AppConfig

class UsersConfig(AppConfig):
    name = 'users'
```

我们将此类添加到工程settings.py中的INSTALLED_APPS列表中，表明注册安装具备此配置属性的应用。

- **AppConfig.name** 属性表示这个配置类是加载到哪个应用的，每个配置类必须包含此属性，默认自动生成。

- **AppConfig.verbose_name** 属性用于设置该应用的直观可读的名字，此名字在Django提供的Admin管理站点中会显示，如

  ```python
  from django.apps import AppConfig
  
  class UsersConfig(AppConfig):
      name = 'users'
      verbose_name = '用户管理'  # 涉及到admin的时候要设置
  ```



#### 1.4 创建视图函数或视图类

*<u>同Flask框架一样，Django也用视图来编写Web应用的业务逻辑。</u>*

*<u>Django的视图是定义在子应用的views.py中的</u>*

##### 1.4.1 打开刚创建的users模块，在views.py中编写视图代码。

```python
from django.http import HttpResponse  # 注意导包的位置, 注意包名; 不要和爬虫中HTTPResponse混淆

def index(request):  # 必须有request参数
    """
    index视图
    :param request: 包含了请求信息的请求对象
    :return: 响应对象
    """
    return HttpResponse("hello the world!")  # 不能直接返回一个字符串
```

说明：

- 视图函数的第一个传入参数必须定义，用于接收Django构造的包含了请求数据的**HttpReqeust**对象，通常名为**request**。
  - ==区别==: **Flask** 中是 `from flask import request` 请求上下文来获取到`request` 对象.
- 视图函数的返回值必须为一个响应对象，不能像**Flask一样直接返回一个字符串**，可以将要返回的字符串数据放到一个**HTTPResponse**对象中。

##### 1.4.2 类视图

<a href="#4.1 类视图">点击跳转(Ctrl+单击)</a>



#### 1.5 定义路由url

##### 1) 在子应用中新建一个`urls.py`文件用于保存该应用的路由。

##### 2) 在users/urls.py文件中定义路由信息。

```python
from django.conf.urls import url  # 导包

from . import views

# urlpatterns是被django自动识别的路由列表变量
urlpatterns = [
    # 每个路由信息都需要使用url函数来构造
    # url(路径, 视图)  元素不是简单的元组,而是url()函数对象
    # 第一个参数: url路径字符串; 
    # 第二个参数: 函数. 所以,类试图需要通过 as_view() 转换成函数.
    url(r'^index/$', views.index),    # $ 结尾, 以防 url 覆盖问题的发生. 但是 项目url不能, 否则报错.
]
```

关于**视图集**,  还有一种设置 url 的方式:

```pyton
router = DefaultRouter()
router.register('app_name', views.App_View_ViewSet, base_name="xxx")
urlpatterns = []
urlpatterns += router.urls
```



##### 3) 在工程总路由demo/urls.py中添加子应用的路由数据。

```python
from django.conf.urls import url, include
from django.contrib import admin

urlpatterns = [
    url(r'^admin/', admin.site.urls),  # django默认包含的

    # 添加
    url(r'^users/', include('users.urls')), 
]
# 该文件上面有关于如何创建 urlpatterns 变量的提示信息, 在创建django项目的时候自动生成
```

- 使用include来将子应用users里的全部路由包含进工程路由中；

- r'^users/' 决定了users子应用的所有路由都已/users/开头，如我们刚定义的视图index，其最终的完整访问路径为/users/index/。

include函数除了可以传递字符串之外，也可以直接传递应用的urls模块，如

```python
from django.conf.urls import url, include
from django.contrib import admin
import users.urls  # 先导入应用的urls模块

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    # url(r'^users/', include('users.urls')),
    url(r'^users/', include(users.urls)),  # 添加应用的路由
]
```

##### 4) 启动运行

重新启动django程序

```shell
python manage.py runserver
```

### 2. 配置、静态文件与路由

#### 2.1 配置文件

##### 1. BASE_DIR

```python
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))  # 这里也可能需要结合实际情况调整.
```

当前工程的根目录，Django会依此来定位工程内的相关文件，我们也可以使用该参数来构造文件路径。

实战:

- 在项目中一般会 创建 apps 文件夹用来 放多个 app , 需要添加到 **python解释器** 的搜索路径中, 代码 `sys.path.insert(0, os.path.join(BASE_DIR, 'apps'))` , 注: 也有使用 `os.path.append()` 方法的; 其次要注意 同时用到 `os` 和 `sys` 模块.
- 类似的还有,  常常需要创建不同环境下的 运行环境, 那么需要在 `manage.py`中修改 django项目的默认配置环境: `os.environ.setdefault("DJANGO_SETTINGS_MODULE", "buyfree_mall.settings.dev")`.

##### 2. SECRET_KEY 

​	该变量是创建 django 项目的时候自动生成的, 其值常用于 加密传输过程, 不要泄露.

##### 3. DEBUG

调试模式，创建工程后初始值为**True**，即默认工作在调试模式下。

作用：

- 修改代码文件，程序自动重启
- Django程序出现异常时，向前端显示详细的错误追踪信息，例如

![error](./img_django/error_trackback.png)

​	而非调试模式下，仅返回Server Error (500)

 **特别注意：部署线上运行的Django不要运行在调式模式下，记得修改DEBUG=False。**

- 如果DEBUG = False , 那么必须要进行  ALLOWED_HOSTS 配置.

##### 4. ALLOWED_HOSTS

​	允许访问的 **域名** 或者 **IP** , 如  ALLOWED_HOSTS=['127.0.0.1', 'www.yuming.com']

​	配置任意:  ALLOWED_HOSTS = ['*']

##### 5. INSTALLED_APPS

- 注意区分 django 不同版本的不同写法.
- django 会自带一部分

##### 6. MIDDLEWARE

- 重点: **关注顺序:** 在视图函数执行之前是从上往下调用, 视图函数执行过程中是从下往上调用.  ( ==需要核实, 视图函数执行结束之后== )
- 通常分为三部分: 
  - 1.django 自带的 app 
  - 2.我们使用三方工具引入的 app
  - 3.我们自己定义的视图 app. `app_name.apps.App_nameConfig`
- 实例

```python
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # 2. 关注顺序(一定要添加到最前面)  # 解决跨域请求
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
```

##### 7. ROOT_URLCONF = 'pro_name.urls'   

​	创建项目,自动生成

##### 8. TEMPLATES  模板配置

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],  # 配置模板文件的目录
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',                			'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

##### 9. WSGI_APPLICATION = 'pro_name.wsgi.application'

##### 10. DATABASES

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # 后端可以配置, mysql、oracle 等等
        'HOST': '127.0.0.1',  # 数据库主机
        'PORT': 3306,  # 数据库端口
        'USER': 'user_name',  # 数据库用户名
        'PASSWORD': 'password',  # 数据库用户密码
        'NAME': 'db_name'  # 数据库名字
    }
}
```

== 考虑数据库集群如何配置, 考虑如何分配用户的权限, 不要直接使用 root 账户, 不安全 ==

##### 11. CACHES  

<u>注: 是django框架中比较重要的部分</u>

配置方式: 以字典的形式配置, 内部元素也是字典, k用于标记保存对应数据的名字, 配置三个值

```python
CACHES = {
    "default": {  # 默认的是用于做什么呢?
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/0",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    "session": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/1",  指明数据库ip:port/库名
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    "verify_codes": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/2",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    "history": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/3",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    },
    "cart": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/4",
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}

# 给admin站点使用的session
SESSION_ENGINE = "django.contrib.sessions.backends.cache"
SESSION_CACHE_ALIAS = "session"
```

*<u>注: redis 数据库也是可以设置 用户名和密码的,  这种情况下有些配置需要添加</u>*

##### 12. AUTH_PASSWORD_VALIDATORS    密码校验



##### 13. 本地语言与时区

<u>*Django支持本地化处理，即显示语言与时区支持本地化。*</u>

本地化是将显示的语言、时间等使用本地的习惯，这里的本地化就是进行中国化，中国大陆地区使用**简体中文**，时区使用**亚洲/上海**时区，注意这里不使用北京时区表示。

初始化的工程默认语言和时区为**英语**和**UTC**标准时区, 但是在做定时任务的时候可能还存在问题.

```python
LANGUAGE_CODE = 'en-us'  # 语言
TIME_ZONE = 'UTC'  # 时区
```

将语言和时区修改为中国大陆信息

```python
LANGUAGE_CODE = 'zh-hans'  # 记忆方式: zhongwen ,  hanyu  s 
TIME_ZONE = 'Asia/Shanghai'

USE_I18N = True
USE_L10N = True
USE_TZ = False  # 使用本地时间, 禁止使用UTC, 否则数据库保存时间会比本地慢8h

# 可以参考:
https://blog.csdn.net/lmb20056127/article/details/77862904
```

![worked](./img_django/chinese_index_page.png)

##### 14. STATIC_URL='/static/'   是 django 的默认配置

```python
STATIC_URL = '/static/'  # 静态文件的前缀, 类比Flask中的 pre_fix
STATICFILES_DIRS = [  # 复数, 配置列表
    os.path.join(BASE_DIR, 'static_files')  
]
# django 一旦 发现传递过来的请求是 /static/..., 那么直接去请求本地的静态文件, 而不会再进行动态url解析.
# django是一个动态框架, 所以在生产模式下, django默认关闭 提供静态文件的功能, 转而提供一个函数来收集静态文件打包交给专门的静态文件服务器处理.
```

==待补充完善,  如何使用打包静态文件的函数==





##### 15. 配置日志



##### 16. REST_FRAMEWORK



##### 17. JWT_AUTH



##### 18. AUTH_USER_MODEL = 'users.User'  # 配置,让django使用我们定义的模型



##### 19. CORS_ORIGIN_WHITELIST













#### 2.2 静态文件

项目中的CSS、图片、js都是静态文件。一般会将静态文件放到一个单独的目录中，以方便管理。在html页面中调用时，也需要指定静态文件的路径，Django中提供了一种解析的方式配置静态文件路径。静态文件可以放在项目根目录下，也可以放在应用的目录下，由于有些静态文件在项目中是通用的，所以**推荐放在项目的根目录下，方便管理**。

为了提供静态文件，需要配置两个参数：

- **STATICFILES_DIRS** 存放查找静态文件的目录    <u>注: `S`说明是容器类型, 可以有多个元素.</u>
- **STATIC_URL** 访问静态文件的URL前缀

##### 示例

1） 在项目根目录下创建static_files目录来保存静态文件。

2） 在demo/settings.py中修改静态文件的两个参数为

```python
STATIC_URL = '/static/'
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static_files'),
]
```

3）此时在static_files添加的任何静态文件都可以使用网址 **/static/文件在static_files中的路径** 来访问了。

例如，我们向static_files目录中添加一个index.html文件，在浏览器中就可以使用127.0.0.1:8000/static/index.html来访问。

或者我们在static_files目录中添加了一个子目录和文件goods/detail.html，在浏览器中就可以使用127.0.0.1:8000/static/goods/detail.html来访问。

##### 注意

Django 仅在调试模式下（DEBUG=True）能对外提供静态文件。

当DEBUG=False工作在生产模式时，Django不再对外提供静态文件，需要是用collectstatic命令来收集静态文件并交由其他静态文件服务器来提供。==（详细在部署时会讲）==

#### 2.3 路由

##### 1. 路由定义位置

Django 在 `settings.py`文件中有根路由`ROOT_URL` 配置.

Django的主要路由信息定义在工程同名目录下的urls.py文件中，该文件是Django解析路由的入口。

每个子应用为了保持相对独立，可以在各个子应用中定义属于自己的urls.py来保存该应用的路由。然后用主路由文件包含各应用的子路由数据。

除了上述方式外，也可将工程的全部路由信息都定义在主路由文件中，子应用不再设置urls.py。如：

```
from django.conf.urls import url
from django.contrib import admin
import users.views

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^users/index/$', users.views.index)
]
```

##### 2. 路由解析顺序

Django在接收到一个请求时，从主路由文件中的urlpatterns列表中以由上至下的顺序查找对应路由规则，如果发现规则为include包含，则再进入被包含的urls中的urlpatterns列表由上至下进行查询。

值得关注的**由上至下**的顺序，有可能会使上面的路由屏蔽掉下面的路由，带来非预期结果。例如：

```python
urlpatterns = [
    url(r'^say', views.say),
    url(r'^sayhello', views.sayhello),
]
```

即使访问sayhello/路径，预期应该进入sayhello视图执行，但实际优先查找到了say路由规则也与sayhello/路径匹配，实际进入了say视图执行。

###### 提示：

**需要注意定义路由的顺序，避免出现屏蔽效应。**

##### 3. 路由命名与reverse反解析（逆向）

###### 3.1 路由命名

在定义路由的时候，可以为路由命名，方便查找特定视图的具体路径信息。

1) 在使用include函数定义路由时，可以使用namespace参数定义路由的命名空间，如

```python
url(r'^users/', include('users.urls', namespace='users')),   # 命名空间
```

命名空间表示，凡是users.urls中定义的路由，均属于namespace指明的users名下。

**命名空间的作用：避免不同应用中的路由使用了相同的名字发生冲突，使用命名空间区别开。**

2) 在定义普通路由时，可以使用name参数指明路由的名字，如

```python
urlpatterns = [
    url(r'^index/$', views.index, name='index'),
    url(r'^say', views.say, name='say'),  # 命名
]
```

###### 3.2 reverse反解析  <u>注: 同Flask 中的 url_for</u>

使用reverse函数，可以根据路由名称，返回具体的路径，如：

```python
from django.core.urlresolvers import reverse  # 注意导包路径

def index(request):
    return HttpResponse("hello the world!")

def say(request):
    url = reverse('users:index')  # 返回 /users/index/
    print(url)
    return HttpResponse('say')
```

- 对于未指明namespace的，reverse(路由name)
- 对于指明namespace的，reverse(命名空间namespace:路由name)     *<u>namespace 是 一个 url集合</u>*
- 类比,  Flask 中的 `url_for`

##### 4. 路径结尾斜线/的说明

Django中定义路由时，通常以斜线/结尾，其好处是用户访问不以斜线/结尾的相同路径时，Django会把用户重定向到以斜线/结尾的路径上，而不会返回404不存在。如

```python
urlpatterns = [
    url(r'^index/$', views.index, name='index'),
]
```

用户访问 index 或者 index/ 网址，均能访问到index视图。

**说明：**

虽然路由结尾带/能带来上述好处，但是却违背了HTTP中URL表示资源位置路径的设计理念。

是否结尾带/以所属公司定义风格为准。

```python
# 关于  301、302 区别和 斜线结尾的知识补充
1. 301 302 浏览器缓存
301 永久重定向, django 会将网页内容保存在本地浏览器缓存中, 如果不清除则下次访问会直接从本地拿取数据;
302 临时重定向, 每次发起请求都是 发起两次请求才拿到资源.

前提: 默认情况下:
    在`urls.py`配置中 如果结尾以 / , 那么在访问的时候:
        如果 没有加/ 且 浏览器本地无缓存, 那么会进行两次请求 301 和 200;
        如果 没有加/ 且 浏览器本地有缓存, 那么会进行一次请求 200; (301灰色)
        如果 加了 / , 均是 200;
    在`urls.py`配置中 如果结尾 不以 / , 那么访问的时候:
        如果 没有加 / , 均是 200;
        如果加 /  , 那么 返回 404 ;
总之: 
    如果配置url正则的时候没有加, 那么django不会自动加上;
    如果配置url正则的时候有加, 那么django会自动加上.
```







### 3. 请求和响应 COOKIE和SESSION

#### 3.1 请求 Request

回想一下，利用**HTTP协议向服务器传参**有几种途径？

- 提取URL的特定部分(路径参数)，如/weather/beijing/2018，可以在服务器端的路由中用正则表达式截取；
- 查询字符串（query string)，形如key1=value1&key2=value2；
- 请求体（body）中发送的数据，如表单数据、json、xml；  *<u>注: 必须是可以传递请求体的method</u>*
- 在http报文的头（header）中。

##### 1 URL路径参数

在定义路由URL时，可以使用正则表达式提取参数的方法从URL中获取请求参数，Django会将提取的参数直接传递到视图的传入参数中。

- 未命名参数按定义顺序传递， 如

  ```python
  # 位置参数变成 关键字参数
  url(r'^weather/([a-z]+)/(\d{4})/$', views.weather),  # url函数自带正则匹配功能
  
  def weather(request, city, year):
      print('city=%s' % city)
      print('year=%s' % year)
      return HttpResponse('OK')
  ```

- 命名参数按名字传递，如

  ```python
  url(r'^weather/(?P<city>[a-z]+)/(?P<year>\d{4})/$', views.weather),  # 这种方式更被推荐一些
  
  def weather(request, year, city):
      print('city=%s' % city)
      print('year=%s' % year)
      return HttpResponse('OK')
  ```

##### 2 Django中的QueryDict对象

定义在django.http.QueryDict

**HttpRequest对象的属性GET、POST都是QueryDict类型的对象**

与python字典不同，QueryDict类型的对象用来处理同**一个键带有多个值**的情况

- 方法get()：根据键获取值

  如果一个键同时拥有多个值将获取最后一个值

  如果键不存在则返回None值，可以设置默认值进行后续处理

  ```python
  dict.get('键',默认值)
  可简写为
  dict['键']
  ```

- 方法getlist()：根据键获取值，值以列表返回，可以获取指定键的所有值

  如果键不存在则返回空列表[]，可以设置默认值进行后续处理

  ```python
  dict.getlist('键',默认值)
  ```

##### 3. 查询字符串Query String

获取请求路径中的查询字符串参数（形如?k1=v1&k2=v2），可以通过request.GET属性获取，返回QueryDict对象。

```python
# /qs/?a=1&b=2&a=3

def qs(request):
    a = request.GET.get('a')
    b = request.GET.get('b')
    alist = request.GET.getlist('a')
    print(a)  # 3
    print(b)  # 2
    print(alist)  # ['1', '3']
    return HttpResponse('OK')
```

**重要：查询字符串不区分请求方式，即假使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串数据。**

##### 4 请求体

请求体数据格式不固定，可以是表单类型字符串，可以是JSON字符串，可以是XML字符串，应区别对待。

可以发送请求体数据的请求方式有**POST**、**PUT**、**PATCH**、**DELETE**。

**Django默认开启了CSRF防护**，会对上述请求方式进行CSRF防护验证，在测试时可以关闭CSRF防护机制，方法为在settings.py文件中注释掉CSRF中间件，如：

![](./img_django/csrf_middleware.png)

###### 4.1 表单类型 Form Data

前端发送的表单类型的请求体数据，可以通过request.POST属性获取，返回QueryDict对象。

```python
def get_body(request):
    a = request.POST.get('a')
    b = request.POST.get('b')
    alist = request.POST.getlist('a')
    print(a)
    print(b)
    print(alist)
    return HttpResponse('OK')
```

**重要：只要请求体的数据是表单类型，无论是哪种请求方式（POST、PUT、PATCH、DELETE），都是使用request.POST来获取请求体的表单数据。结果也是QueryDict类型.**

###### 4.2 非表单类型 Non-Form Data

非表单类型的请求体数据，Django无法自动解析，可以通过**request.body**属性获取最原始的请求体数据，自己按照请求体格式（JSON、XML等）进行解析。**request.body返回bytes类型。**

**注意: 请求体的数据在提交的时候, 还要注意需要配套 `Content-Type:xxx`**

例如要获取请求体中的如下JSON数据

```json
{"a": 1, "b": 2}
```

可以进行如下方法操作：

```python
import json

def get_body_json(request):
    json_str = request.body
    json_str = json_str.decode()  # python3.6 无需执行此步
    req_data = json.loads(json_str)
    print(req_data['a'])
    print(req_data['b'])
    return HttpResponse('OK')
```

##### 5 请求头

可以通过**request.META**属性获取请求头headers中的数据，**request.META为字典类型**。

*<u>注: django中的请求头的写法部分和 历览器中看到的请求头的写法有一些细小的差别. django把字符全部转换成大写, 然后将横杠变成下划线</u>*

常见的请求头如：

- `CONTENT_LENGTH` – The length of the request body (as a string).
- `CONTENT_TYPE` – The MIME type of the request body.
- `HTTP_ACCEPT` – Acceptable content types for the response.
- `HTTP_ACCEPT_ENCODING` – Acceptable encodings for the response.
- `HTTP_ACCEPT_LANGUAGE` – Acceptable languages for the response.
- `HTTP_HOST` – The HTTP Host header sent by the client.
- `HTTP_REFERER` – The referring page, if any.
- `HTTP_USER_AGENT` – The client’s user-agent string.
- `QUERY_STRING` – The query string, as a single (unparsed) string.
- `REMOTE_ADDR` – The IP address of the client.
- `REMOTE_HOST` – The hostname of the client.
- `REMOTE_USER` – The user authenticated by the Web server, if any.
- `REQUEST_METHOD` – A string such as `"GET"` or `"POST"`.
- `SERVER_NAME` – The hostname of the server.
- `SERVER_PORT` – The port of the server (as a string).

具体使用如:

```python
def get_headers(request):
    print(request.META['CONTENT_TYPE'])
    return HttpResponse('OK')
```

##### 6 其他常用HttpRequest对象属性

- **method**：一个**字符串**，表示请求使用的HTTP方法，常用值包括：'GET'、'POST'。
- **user：请求的用户对象。**
- path：一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。
- encoding：一个字符串，表示提交的数据的编码方式。
  - 如果为None则表示使用浏览器的默认设置，一般为utf-8。
  - 这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的encoding值。

- FILES：一个类似于字典的对象，包含所有的上传文件。

```python
# 小结一下:
1. request 是django封装的对象(HttpRequest), 具有一些常用的属性和方法, 比如  GET, POST, user, method等
2. request 是django中基于应用层(HTTP协议)的对象, 所以其通过前端传递参数的方式有 4 种, 分别是:
    2.1 位置(路径)参数, 可以直接通过 django 提供的正则方式(小括号)提取;  或者通过命名的方式(?P<name>)转化成 命名参数 , 在参数较复杂的情况下推荐使用;
    2.2.0: QueryDict 对象, 父类是python中的dict, 但是它可以处理 '一键多值'
    2.2 查询参数(query_params), 即?k=v, 存在一键多值, 取最后一个. 通过 reqeust对象的 GET 属性(其返回值是: QueryDict)获取, request.GET.get()  或 request.GET.getlist() -- 获取的是一个列表(会覆盖);
    2.3 请求体(body), 在 原生 django 中要分成两类:
        2.3.1 表单类型, 通过 POST属性的 get 和 getlist 获取. 返回的也是 QueryDict对象
        2.3.2 非表单类型(xml, json, 二进制等) , 通过 body 属性获取, 是'bytes'对象,要用其对应类型的方式获取.如json, json.loads()方法
    2.4 请求头(header), 通过 META 属性获取, 返回的是 'dict' 对象.如, request.META['CONTENT_TYPE']
3. 其他常用属性
# 总之, 要搞清楚 HttpRequest对象(通常在视图中用 reqeust 参数来引用)的常用属性, 以及对应的 前端传递参数的类型, 以及每种属性的返回值是什么?返回值的不同类型决定了其取值方式的不同.

# 其他补充:
在Flask中是通过 视图函数增加路由装饰器, <int:xx> 这种 路由转换器, django 直接通过 url()函数的正则方法, 提取 () 中的原子.
大P 表示 参数 params 的意思
查询参数是 get post 都可以提交的,因为他们保存在 请求报文中的请求行 中, 这种分析思路要具备, 考虑一种传递参数的方式是否可以被 不同的方法所使用其核心还是判断 不同的请求方式的请求报文的构成.

# django 中 视图函数是不限制访问方式的, 类视图中指明的除外; Flask 通过 method 来指明.
```





#### 3.2 响应 Response

视图在接收请求并处理后，必须返回HttpResponse对象或子对象。HttpRequest对象由Django创建，HttpResponse对象由开发人员创建。

##### 1 HttpResponse

可以使用**django.http.HttpResponse**来构造响应对象。

```python
HttpResponse(content=响应体, content_type=响应体数据类型, status=状态码)
```

也可通过HttpResponse对象属性来设置响应体、响应体数据类型、状态码：

- content：表示返回的内容。
- status_code：返回的HTTP响应状态码。
- content_type：指定返回数据的的MIME类型。

**响应头**可以直接将HttpResponse对象当做字典进行响应头键值对的设置：

```python
response = HttpResponse()
response['language'] = 'Python'  # 自定义响应头language, 值为Python
```

示例：

```python
from django.http import HttpResponse

def demo_view(request):
    return HttpResponse('language python', status=400)
    或者
    response = HttpResponse('language python')
    response.status_code = 400  # 通过属性的方式设置
    response['language'] = 'Python'
    return response
```

##### 2 HttpResponse子类

Django提供了一系列HttpResponse的子类，可以快速设置状态码

- HttpResponseRedirect 301
- HttpResponsePermanentRedirect 302
- HttpResponseNotModified 304
- HttpResponseBadRequest 400
- HttpResponseNotFound 404
- HttpResponseForbidden 403
- HttpResponseNotAllowed 405
- HttpResponseGone 410
- HttpResponseServerError 500

##### 3 JsonResponse

若要返回json数据，可以使用JsonResponse来构造响应对象，作用：

- 1. 帮助我们将数据转换为json字符串
- 2. 设置响应头**Content-Type**为 **application/json**

```python
from django.http import JsonResponse

def demo_view(request):
    return JsonResponse({'city': 'beijing', 'subject': 'python'})
```

##### 4 redirect重定向

```python
from django.shortcuts import redirect

def demo_view(request):
    return redirect('/index.html')
```





#### 3.3 Cookie

​	Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型记住用户名。

Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。

**Cookie的特点**

- Cookie以键值对的格式进行信息的存储。
- Cookie**基于域名安全**，不同域名的Cookie是不能互相访问的，如访问google.cn时向浏览器中写了Cookie信息，使用同一浏览器访问baidu.com时，无法访问到google.cn写的Cookie信息。
- 当浏览器请求某网站时，会**(自动)**将浏览器存储的跟网站相关的所有Cookie信息提交给网站服务器。
##### 1 设置Cookie
可以通过HttpResponse对象中的set_cookie方法来设置cookie。

```python
HttpResponse.set_cookie(cookie名, value=cookie值, max_age=cookie有效期)
```

- **max_age** 单位为秒，默认为**None**。如果是临时cookie，可将max_age设置为None。
示例：
```python
def demo_view(request):
    response = HttpResponse('ok')
    response.set_cookie('language1', 'python1')  # 临时cookie
    response.set_cookie('language2', 'python2', max_age=3600)  # 有效期一小时
    return response
```
##### 2 读取Cookie
可以通过**HttpRequest对象**的**COOKIES**属性来读取本次请求携带的cookie值。**request.COOKIES为字典类型**。
```python
def demo_view(request):
    cookie1 = request.COOKIES.get('language1')
    print(cookie1)
    return HttpResponse('OK')
```

#### 3.4 Session

##### 1 启用Session

**Django项目默认启用Session。**

可以在settings.py文件中查看，如图所示

![](./img_django/session_middleware.png)

如需禁用session，将上图中的session中间件注释掉即可。

##### 2 存储方式

在settings.py文件中，可以设置session数据的存储方式，可以保存在数据库、本地缓存等。

##### 2.1 数据库

存储在数据库中，如下设置可以写，也可以不写，**这是默认存储方式**。

```python
SESSION_ENGINE='django.contrib.sessions.backends.db'
```

如果存储在数据库中，需要在项INSTALLED_APPS中安装Session应用。

![](./img_django/session_app.png)

数据库中的表如图所示

![](./img_django/session_database.png)

表结构如下

![](./img_django/session_table.png)

由表结构可知，操作Session包括三个数据：键，值，过期时间。

##### 2.2 本地缓存

存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。

```python
SESSION_ENGINE='django.contrib.sessions.backends.cache'
```

**注意:** **<u>本地缓存可能存在跨机的问题, 当有多台服务器的时候分别保存在各自的本地, 那么不同的请求可能会访问不同的主机,而session只保存在其中的一台主机上, 所以可能会出现问题. 用redis, 搭建在一台单独的主机上解决.</u>**

##### 2.3 混合存储

优先从本机内存中存取，如果没有则从数据库中存取。

```python
SESSION_ENGINE='django.contrib.sessions.backends.cached_db'
```

##### 2.4 Redis

在redis中保存session，需要引入第三方扩展，我们可以使用**django-redis**来解决。

1） 安装扩展

```python
pip install django-redis  # 综合后端, 既可以当作 server来使用, 还可以当作 client 来使用.
```

2）配置

在settings.py文件中做如下设置:

```python
# django 中引入 redis 的本质原理还是, 利用了 redis 的引擎: cache, 所以下面的配置有 SESSION_ENGINE, 指向cache, 只不过把 CACHE 后端给修改成 RedisCache, 而不是在本地的内存中.

CACHES = {
    "default": {
        "BACKEND": "django_redis.cache.RedisCache",
        "LOCATION": "redis://127.0.0.1:6379/1",  # 指明redis的位置.
        "OPTIONS": {
            "CLIENT_CLASS": "django_redis.client.DefaultClient",
        }
    }
}
SESSION_ENGINE = "django.contrib.sessions.backends.cache"
SESSION_CACHE_ALIAS = "default"  # 将操作django的 cache 和 rediscache 联系起来.
```

###### 注意

如果redis的ip地址不是本地回环127.0.0.1，而是其他地址，访问Django时，可能出现Redis连接错误，如下：

![](./img_django/redis_connect_error.png)

解决方法：

修改redis的配置文件，添加特定ip地址。

打开redis的配置文件

```shell
sudo vim /etc/redis/redis.conf
```

在如下配置项进行修改（如要添加10.211.55.5地址）

![](./img_django/modify_redis_config.png)

重新启动redis服务

```shell
sudo service redis-server restart
```

##### 3 Session操作

通过HttpRequest对象的session属性进行会话的读写操作。

1） 以键值对的格式写session。

```
request.session['键']=值
```

2）根据键读取值。

```
request.session.get('键',默认值)
```

3）清除所有session，在存储中删除值部分。

```python
request.session.clear()  # 只删值
```

4）清除session数据，在存储中删除session的整条数据。

```
request.session.flush()  # 如果非redis数据库也是这个操作嘛?
```

5）删除session中的指定键及值，在存储中只删除某个键及对应的值。

```
del request.session['键']
```

6）设置session的有效期

```
request.session.set_expiry(value)
```

- 如果value是一个整数，session将在value秒没有活动后过期。
- 如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。
- 如果value为None，那么session有效期将采用系统默认值，**默认为两周**，可以通过在settings.py中设置**SESSION_COOKIE_AGE**来设置全局默认值。

---

关于session还有很多内容需要深入了解

---

### 4. 类视图与中间件

#### 4.1 类视图  

<a href="#1.4.2 类视图">点击返回(Ctrl+点击)</a>

##### 1 类视图引入

以函数的方式定义的视图称为**函数视图**，函数视图便于理解。但是遇到一个视图对应的路径提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都不佳。

```python
 def register(request):
    """处理注册"""

    # 获取请求方法，判断是GET/POST请求
    if request.method == 'GET':
        # 处理GET请求，返回注册页面
        return render(request, 'register.html')
    else:
        # 处理POST请求，实现注册逻辑
        return HttpResponse('这里实现注册逻辑')
```

在Django中也可以使用类来定义一个视图，称为**类视图**。

使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义。如下所示

```python
from django.views.generic import View

class RegisterView(View):
    """类视图：处理注册"""

    def get(self, request):
        """处理GET请求，返回注册页面"""
        return render(request, 'register.html')

    def post(self, request):
        """处理POST请求，实现注册逻辑"""
        return HttpResponse('这里实现注册逻辑')
```

类视图的好处：

- **代码可读性好**
- **类视图相对于函数视图有更高的复用性**， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可

##### 2 类视图使用

定义类视图需要继承自Django提供的父类**View**，可使用`from django.views.generic import View`或者`from django.views.generic.base import View` 导入，定义方式如上所示。

**配置路由时，使用类视图的as_view()方法来添加**。

```python
urlpatterns = [
    # 视图函数：注册
    # url(r'^register/$', views.register, name='register'),
    # 类视图：注册
    url(r'^register/$', views.RegisterView.as_view(), name='register'),
]
```

##### 3 类视图原理

```python
    @classonlymethod  # django封装的类方法, 所以url配置第二个参数要用类名调用
    def as_view(cls, **initkwargs):
        """
        Main entry point for a request-response process.
        """
        ...省略代码...

        def view(request, *args, **kwargs):
            self = cls(**initkwargs)
            if hasattr(self, 'get') and not hasattr(self, 'head'):
                self.head = self.get
            self.request = request
            self.args = args
            self.kwargs = kwargs
            # 调用dispatch方法，按照不同请求方式调用不同请求方法
            return self.dispatch(request, *args, **kwargs)

        ...省略代码...

        # 返回真正的函数视图
        return view


    def dispatch(self, request, *args, **kwargs):
        # Try to dispatch to the right method; if a method doesn't exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn't on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
        return handler(request, *args, **kwargs)
```

##### 4 类视图使用装饰器

为类视图添加装饰器，可以使用三种方法(url配置中装饰; 为特定的请求方式添加装饰器; 使用扩展类)。

为了理解方便，我们先来定义一个**为函数视图准备的装饰器**（在设计装饰器时基本都以函数视图作为考虑的被装饰对象），及一个要被装饰的类视图。

```python
def my_decorator(func):
    def wrapper(request, *args, **kwargs):
        print('自定义装饰器被调用了')
        print('请求路径%s' % request.path)
        return func(request, *args, **kwargs)
    return wrapper

class DemoView(View):
    def get(self, request):
        print('get方法')
        return HttpResponse('ok')

    def post(self, request):
        print('post方法')
        return HttpResponse('ok')
```

###### 4.1 在URL配置中装饰

```python
urlpatterns = [
    url(r'^demo/$', my_decorate(DemoView.as_view()))
]
```

此种方式最简单，但因装饰行为被放置到了url配置中，单看视图的时候无法知道此视图还被添加了装饰器，不利于代码的完整性，不建议使用。

**此种方式会为类视图中的所有请求方法都加上装饰器行为**（因为是在视图入口处，分发请求方式前）。

> 补充关于 **装饰器** 的理解:
>
> 装饰器就是在原来函数外面装了一层壳,然后再赋值给原函数
>
> `func = my_deractor(func)`

###### 4.2 在类视图中装饰

在类视图中使用为函数视图准备的装饰器时，不能直接添加装饰器，需要使用**method_decorator**将其转换为适用于类视图方法的装饰器。

**method_decorator装饰器使用name参数指明被装饰的方法**

*<u>注: method_decorator 是django封装的方法, 使得我们可以像装饰函数一样来装饰 django类视图中的方法</u>*

**思考:  为何要封装方法才能处理 类视图 的方法?**

> **参数个数变化, 对应不上.**具体来说:
>
> 因为源码中, dispatch()等方法都是类方法, 其第一个参数都是 `self` , django处理之后会添加上 self , 和原来view函数的参数 `def view(request, *args, **kwargs):` 进行补充.

```python
# 1. 为全部请求方法添加装饰器
# 思考: 为何要指明 dispatch 而不选用 view 方法?  答:取不到
@method_decorator(my_decorator, name='dispatch')
class DemoView(View):
    def get(self, request):
        print('get方法')
        return HttpResponse('ok')

    def post(self, request):
        print('post方法')
        return HttpResponse('ok')


# 2. 为特定请求方法添加装饰器
@method_decorator(my_decorator, name='get')
class DemoView(View):
    def get(self, request):
        print('get方法')
        return HttpResponse('ok')

    def post(self, request):
        print('post方法')
        return HttpResponse('ok')
```

**如果需要为类视图的多个方法添加装饰器，但又不是所有的方法（为所有方法添加装饰器参考上面例子），可以直接在需要添加装饰器的方法上使用method_decorator，如下所示**

```python
from django.utils.decorators import method_decorator

# 为特定请求方法添加装饰器
class DemoView(View):

    @method_decorator(my_decorator)  # 为get方法添加了装饰器
    def get(self, request):
        print('get方法')
        return HttpResponse('ok')

    @method_decorator(my_decorator)  # 为post方法添加了装饰器
    def post(self, request):
        print('post方法')
        return HttpResponse('ok')

    def put(self, request):  # 没有为put方法添加装饰器
        print('put方法')
        return HttpResponse('ok')
```

##### 5 类视图Mixin扩展类

>  类视图Mixin扩展类装饰器引入:
>
> ```python
> class BaseViewMixin(View):
>     
>     @classmethod  # 重写类方法 as_view
>     def as_view(cls, *args, **kwargs):
>         view = super().as_view()  # 获取父类的 view函数, 然后对其进行装饰
>         view = mydecorator(view)
>         return view
> 
>  class DemoView(BaseView):
>     def get(self, request):
>         return HttpResponse('response body')
>     def post(self, request):
>         return HttpResponse("响应体")
> ```
>
>

**使用面向对象多继承的特性，可以通过定义父类（作为扩展类），在父类中定义想要向类视图补充的方法，类视图继承这些扩展父类，便可实现代码复用。**

定义的扩展父类名称通常以**Mixin结尾**。

举例如下：

```python
class ListModelMixin(object):
    """
    list扩展类
    """
    def list(self, request, *args, **kwargs):
        ...

class CreateModelMixin(object):
    """
    create扩展类
    """
    def create(self, request, *args, **kwargs):
        ...

class BooksView(CreateModelMixin, ListModelMixin, View):
    """
    同时继承两个扩展类，复用list和create方法
    """
    def get(self, request):
        self.list(request)
        ...

    def post(self, request):
        self.create(request)
        ...

class SaveOrderView(CreateModelMixin, View):
    """
    继承CreateModelMixin扩展类，复用create方法
    """
    def post(self, request):
        self.create(request)
        ...
```

> 补充 **多继承**  探讨:
>
> 不同爷爷(View1和View2)--深度优先;  相同爷爷(最后一层,同一个爷爷View)-- 广度优先.
>
> ![不同爷爷](./img_django/不同爷爷垂直顺序.png)
>
> ![相同爷爷](./img_django/相同爷爷水平顺序.png)
>
> 思考2:
>
> 为什么要将 `django` 提供的原本的 `view` 作为爷爷放在多继承的最后, 因为同一个爷爷在python中是 **广度优先** , 保证前面所有的 view 都执行完需要的装饰之后再执行 原来的 view. 
>
> 而 如果是 **深度优先** 那么可能在部分需要 **扩展的view** 执行之前原来的 view 率先执行, 则达不到需要的效果.



#### 4.2 中间件

Django中的中间件是一个**轻量级、底层的**插件系统，可以**介入Django的请求和响应处理过程**，修改Django的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。

我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。

*<u>注: 关于使用 类视图装饰器和中间件是一个选择问题, 结合需求来处理. 如果是更普遍通用的功能需求更加推荐中间件.</u>*

**对所有的 视图函数 生效 !  相对 类视图装饰器 更加广泛**

##### 4.2.1 中间件的定义方法

**定义一个中间件工厂函数，然后返回一个可以被调用的中间件。**

中间件工厂函数需要接收一个可以调用的`get_response对象`。

返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个request对象参数，返回一个response对象。

```python
def simple_middleware(get_response):
    # 此处编写的代码仅在Django第一次配置和初始化的时候执行一次。
    # 可以类比 Flask 中的  before_first_request 请求钩子的代码

    def middleware(request):
        # 此处编写的代码会在每个请求处理视图前被调用。
        # 可类比 Flask 中的 before_request 请求钩子的代码

        response = get_response(request)

        # 此处编写的代码会在每个请求处理视图之后被调用。
        # 类比 Flask 的 after_rqeust 请求钩子

        return response

    return middleware
```

例如，在**users应用**中新建一个`middleware.py`文件，

```python
def my_middleware(get_response):
    print('init 被调用')
    def middleware(request):
        print('before request 被调用')
        response = get_response(request)
        print('after response 被调用')
        return response
    return middleware
```

**定义好中间件后，需要在settings.py 文件中添加注册中间件**

```python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'users.middleware.my_middleware',  # 添加中间件
]
```

定义一个视图进行测试

```python
def demo_view(request):
    print('view 视图被调用')
    return HttpResponse('OK')
```

执行结果

![中间件测试](./img_django/middleware_demo.png)

**注意：Django运行在调试模式下，中间件init部分有可能被调用两次。** 生产模式一次

##### 4.2.2 执行流程

![中间件执行流程](./img_django/中间件执行流程.png)

##### 4.2.3 多个中间件的执行顺序

- 在请求视图被处理**前**，中间件**由上至下**依次执行
- 在请求视图被处理**后**，中间件**由下至上**依次执行

![中间件顺序](./img_django/middleware_sequence.png)

示例：

定义两个中间件

```python
def my_middleware(get_response):
    print('init 被调用')
    def middleware(request):
        print('before request 被调用')
        response = get_response(request)
        print('after response 被调用')
        return response
    return middleware

def my_middleware2(get_response):
    print('init2 被调用')
    def middleware(request):
        print('before request 2 被调用')
        response = get_response(request)
        print('after response 2 被调用')
        return response
    return middleware
```

注册添加两个中间件

```python
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'users.middleware.my_middleware',  # 添加
    'users.middleware.my_middleware2',  # 添加
]
```

执行结果

```python
init2 被调用
init 被调用
before request 被调用
before request 2 被调用
view 视图被调用
after response 2 被调用
after response 被调用
```

执行结果小结:

```python
# 1. 初始化的情况下, 定义在下面的 中间件反而 先执行;
# 2.1多个不同的中间件有一个 "从上往下, 从下往上"的执行顺序; 
# 2.2而同一个中间件内部也有自身的执行顺序, "初始化, 视图之前, 视图自身, 视图之后"

最贴切的比喻是:  用竹签穿过一只洋葱.
```





### 5. 数据库

#### 5.0 介绍

##### ORM框架

O是object，也就**类对象**的意思，R是relation，翻译成中文是关系，也就是关系数据库中**数据表**的意思，M是mapping，是**映射**的意思。在ORM框架中，它帮我们把类和数据表进行了一个映射，可以让我们**通过类和类对象就能操作它所对应的表格中的数据**。ORM框架还有一个功能，它可以**根据我们设计的类自动帮我们生成数据库中的表格**，省去了我们自己建表的过程。

django中**内嵌了ORM框架**，不需要直接面向数据库编程，而是定义模型类，通过模型类和对象完成数据表的增删改查操作。

>  **使用django进行数据库开发的步骤如下：**
>
> 1. **配置数据库连接信息**
> 2. **在models.py中定义模型类**
> 3. **迁移**
> 4. **通过类和对象完成数据增删改查操作**

```python
关于ORM的理解:
    提供一个"框架", 让我们可以 直接操作类来转化成 原生的SQL语句;
    django(程序)和数据库之间通信,采用的是 tcp 通信网络链接, 需要依赖数据库驱动,才能将原生的SQL语句从 框架(程序)端传递给 关系型数据库. 我们需要进行配置ip和port等.
    在Flask中,我们除了需要 sqlalchemy , 我们还需要依赖 flask-mysqldb
    在 django 中框架 只认 mysqldb 库,但是其只支持 python2 的版本. 而python3不再支持 mysqldb, 所以需要安装  pymsql
# 代码如下:
import pymysql
pymysql.install_as_MySQLdb()
```



##### **ORM作用**

![orm](./img_django/orm.png)

![orm](./img_django/orm2.png)



#### 5.1 配置

在settings.py中保存了数据库的连接配置信息，Django默认初始配置使用**sqlite**数据库。

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
```

1. 使用**MySQL**数据库首先需要安装驱动程序

   ```shell
   pip install PyMySQL
   ```

2. 在Django的工程同名子目录的`__init__.py`文件中添加如下语句,在初始化进行配置

   ```python
   from pymysql import install_as_MySQLdb
   
   install_as_MySQLdb()
   ```

   作用是让Django的ORM能以mysqldb的方式来调用PyMySQL。

3. 修改**DATABASES**配置信息

   ```python
   DATABASES = {
       'default': {
           'ENGINE': 'django.db.backends.mysql',
           'HOST': '127.0.0.1',  # 数据库主机
           'PORT': 3306,  # 数据库端口
           'USER': 'root',  # 数据库用户名
           'PASSWORD': 'mysql',  # 数据库用户密码
           'NAME': 'django_demo'  # 数据库名字
       }
   }
   ```

4. 在MySQL中创建数据库

   ```mysql
   create database django_demo default charset=utf8;
   ```



#### 5.2 定义模型类

- 模型类被定义在"应用的`models.py`"文件中。
- 模型类必须继承自Model类，位于`包django.db.models`中。

接下来首先以"图书-英雄"管理为例进行演示。

##### 1 定义

创建应用book，在models.py 文件中定义模型类。

> 补充知识:
>
> - `django`中 模型类的字段在表中是真实存在的, 包括 **relationship 字段**, 这个和 Flask中是有区别的.
> - 不需要我们去主动创建 数据库实例, 直接通过 类的继承 即可. 不同于 Flask. ==待补充==
>
> - `django` 会自动生成主键, 并且是自增的, 不需要我们自己去创建和指明. 如果我们想**设置自己的主键**, 那么在**某个字段**选项指明为主键即可, 默认的主键则自动生效并且不会被创建.  而且可以直接去 通过 `模型类.id`来进行查询等操作.

```python
from django.db import models  # 导包 和 继承

#定义图书模型类BookInfo
class BookInfo(models.Model):
    title = models.CharField(max_length=20, verbose_name='名称')
    pub_date = models.DateField(verbose_name='发布日期')
    read = models.IntegerField(default=0, verbose_name='阅读量')
    comment = models.IntegerField(default=0, verbose_name='评论量')
    is_delete = models.BooleanField(default=False, verbose_name='逻辑删除')

    class Meta:
        db_table = 'tb_books'  # 指明数据库表名
        verbose_name = '图书'  # 在admin站点中显示的名称
        verbose_name_plural = verbose_name  # 显示的复数名称

    def __str__(self):
        """定义每个数据对象的显示信息"""
        return self.title

#定义英雄模型类HeroInfo
class HeroInfo(models.Model):
    GENDER_CHOICES = (  # 枚举类型, 元组包裹, 其内部的元素也是元组
        (0, 'male'),  # 第一个元素是: 数据库中的value, 第二个对应的注释.
        (1, 'female')
    )
    name = models.CharField(max_length=20, verbose_name='名称') 
    gender = models.SmallIntegerField(choices=GENDER_CHOICES, default=0, verbose_name='性别')  # SmallIntegerField 小整数字段, 枚举
    comment = models.CharField(max_length=200, null=True, verbose_name='描述信息')  # null 可以为空 
    book = models.ForeignKey(BookInfo, on_delete=models.CASCADE, verbose_name='图书')  # 外键
    # 第一个参数是关联的模型类.然后自动将模型类的主键作为该 字段 的约束, 该字段的类型也就确定为 IntegerField.
    # 级联. 第二个参数: 来指明"一"和"多"删除操作的时候的不同选项.从django1.9之后都建议指明.  参考下面的选项.
    # 该属性的显示信息, 区别: 在 django中是 模型对象, 而在Flask中是对应的值. 
    # 会自动在数据库表中保存为 hbook_id
    is_delete = models.BooleanField(default=False, verbose_name='逻辑删除')

    class Meta:
        db_table = 'tb_heroes'
        verbose_name = '英雄'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.hname
```

**1） 数据库表名**

模型类如果未指明表名，Django默认以 `**小写app应用名_小写模型类名**` 为数据库表名。

可通过**db_table** 指明数据库表名。

**2） 关于主键**

django会为表创建自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后django不会再创建自动增长的主键列。

默认创建的主键列属性为id，可以使用pk代替，pk全拼为primary key。

**3） 属性命名限制**

- 不能是python的保留关键字。

- 不允许使用连续的下划线，这是由django的查询方式决定的。

- 定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：

  ```python
  属性=models.字段类型(选项)
  ```

**4）字段类型**

| 类型              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| AutoField         | 自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性. 和我们自己指定的某些id无关. |
| BooleanField      | 布尔字段，值为True或False                                    |
| NullBooleanField  | 支持Null、True、False三种值                                  |
| CharField         | 字符串，参数max_length表示最大字符个数, max_length参数必填.  |
| TextField         | 大文本字段，一般超过4000个字符时使用                         |
| SmallIntegerField | 小整数, 搭配 枚举类型 使用                                   |
| IntegerField      | 整数                                                         |
| DecimalField      | 十进制浮点数， 参数max_digits表示总位数， 参数decimal_places表示小数位数 |
| FloatField        | 浮点数                                                       |
| DateField         | 日期， 参数auto_now表示每次保存对象时，自动设置该字段为当前时间，用于"最后一次修改"的时间戳，它总是使用当前日期，默认为False； 参数auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为False; 参数auto_now_add和auto_now是相互排斥的，组合将会发生错误<br /><u>*友情提示: 需要在django的settings.py文件中做好 时区 配置, 否则保存在数据库中的时间要比当前时间慢8h.</u>* |
| TimeField         | 时间，参数同DateField                                        |
| DateTimeField     | 日期时间，参数同DateField                                    |
| FileField         | 上传文件字段                                                 |
| ImageField        | 继承于FileField，对上传的内容进行校验，确保是有效的图片      |

**5） 选项**

| 选项        | 说明                                                         |
| ----------- | ------------------------------------------------------------ |
| null        | 如果为True，表示允许为空(不填)，默认值是False                |
| blank       | 如果为True，则该字段允许为空白，默认值是False                |
| db_column   | 字段的名称，如果未指定，则使用属性的名称. (模型类的属性名和数据库具体字段名可以不相同, 可以对字段名进行设置.) |
| db_index    | 若值为True, 则在表中会为此字段创建索引，默认值是False        |
| default     | 默认                                                         |
| primary_key | 若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用 |
| unique      | 如果为True, 这个字段在表中必须有唯一值，默认值是False        |

**null是数据库范畴的概念，blank是表单验证范畴的**

> 具体解释:
>
> null是数据库表的 概念, 来控制写入数据表的字段是否可以为空;
>
> blank 是 **表单和模板** 的概念, 具体提交的字段是否 **可以不填, 或者填空白字符.** 一般很少涉及到.

**6） 外键**

在设置外键时，需要通过**on_delete**选项指明主表删除数据时，对于外键引用表数据如何处理，在django.db.models中包含了可选常量：

- **CASCADE** 级联，删除主表数据时连通一起删除外键表中数据

- **PROTECT** 保护，通过抛出**ProtectedError**异常，来阻止删除主表中被外键应用的数据

- **SET_NULL** 设置为NULL，仅在该字段null=True允许为null时可用

- **SET_DEFAULT** 设置为默认值，仅在该字段设置了默认值时可用

- **SET()** 设置为特定值或者调用特定方法，如

  ```python
  from django.conf import settings
  from django.contrib.auth import get_user_model
  from django.db import models
  
  def get_sentinel_user():
      return get_user_model().objects.get_or_create(username='deleted')[0]
  
  class MyModel(models.Model):
      user = models.ForeignKey(
          settings.AUTH_USER_MODEL,
          on_delete=models.SET(get_sentinel_user),
      )
  ```

- **DO_NOTHING** 不做任何操作，如果数据库前置指明级联性，此选项会抛出**IntegrityError**异常

##### 2 迁移

将模型类同步到数据库中。需要说明: 这里的数据库迁移比Flask数据库迁移要简单.

**1）生成迁移文件**

```python
python manage.py makemigrations
```

**2）同步到数据库中**

```python
python manage.py migrate
```

##### 3 添加测试数据

```mysql
insert into tb_books(title,pub_date,`read`,comment,is_delete) values
('射雕英雄传','1980-5-1',12,34,0),
('天龙八部','1986-7-24',36,40,0),
('笑傲江湖','1995-12-24',20,80,0),
('雪山飞狐','1987-11-11',58,24,0);

-- 坑: read 是mysql的关键字, 这里需要 `` 包裹.

insert into tb_heros(name,gender,book_id,comment,is_delete) values
('郭靖',1,1,'降龙十八掌',0),
('黄蓉',0,1,'打狗棍法',0),
('黄药师',1,1,'弹指神通',0),
('欧阳锋',1,1,'蛤蟆功',0),
('梅超风',0,1,'九阴白骨爪',0),
('乔峰',1,2,'降龙十八掌',0),
('段誉',1,2,'六脉神剑',0),
('虚竹',1,2,'天山六阳掌',0),
('王语嫣',0,2,'神仙姐姐',0),
('令狐冲',1,3,'独孤九剑',0),
('任盈盈',0,3,'弹琴',0),
('岳不群',1,3,'华山剑法',0),
('东方不败',0,3,'葵花宝典',0),
('胡斐',1,4,'胡家刀法',0),
('苗若兰',0,4,'黄衣',0),
('程灵素',0,4,'医术',0),
('袁紫衣',0,4,'六合拳',0);
```

#### 5.3 shell工具使用及mysql数据库日志动态展示

##### 1 shell工具

Django的manage工具提供了**shell**命令，帮助我们**配置好当前工程的运行环境（如连接好数据库等）**，以便可以直接在终端中执行测试python语句。

通过如下命令进入shell

```python
python manage.py shell
```

![django shell](./img_django/django_shell.png)

> 二、重要提示:
>
> - 在  `test.py` 文件中写命令, 会有提示且方便修改.
> - 如果发生模型类的修改, 需要先 `quit()` 退出交互终端, 重新进入.
> - 模型类中有些处理比较模糊, 比如 id=1 和 id="1"都会有效,  date(1999,1,1) 和 '1999-1-1' 也都有效.

导入两个模型类，以便后续使用

```python
from booktest.models import BookInfo, HeroInfo
```

##### 2 查看MySQL数据库日志

*<u>**注: 可以通过动态查看来观察 django 如何通过 orm 来写出 sql语句**</u>*

查看mysql数据库日志可以查看对数据库的操作记录。 mysql日志文件默认没有产生，需要做如下配置：

```shell
sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
```

![mysql 日志](./img_django/mysql_log.png)

把68，69行前面的#去除，然后保存并使用如下命令重启mysql服务。

```shell
sudo service mysql restart
```

使用如下命令打开mysql日志文件。

```shell
tail -f /var/log/mysql/mysql.log  # 可以实时查看数据库的日志内容
# 如提示需要sudo权限，执行
# sudo tail -f /var/log/mysql/mysql.log
```

#### 5.4 数据库操作—增、删、改、查

##### 1 增加

增加数据有两种方法。

**1）save**

通过创建模型类对象，执行对象的save()方法保存到数据库中。

> - 1.实例模型类对象
> - 2.赋值
> - 3.调用实例的 save() 方法

```python
>>> from datetime import date
>>> book = BookInfo(
    title='西游记',
    pub_date=date(1988,1,1),
    read=10,
    comment=10
)
>>> book.save()  # 执行这一步才会保存到数据库
>>> hero = HeroInfo(
    name='孙悟空',
    gender=0,
    book=book  # 外键关联, 这里是方式之一, 可以直接传递对象. 因为上面正好有查询过 book 模型对象.
)
>>> hero.save()
>>> hero2 = HeroInfo(
    name='猪八戒',
    gender=0,
    book_id=book.id  # 方式之二, 可以这几使用django自动创建的 hbook_id 字段, 然后将 关联的 book.id 赋值给它.
)
>>> hero2.save()
```

**2）create**

通过模型类的objects属性的create()保存。  `模型类.objects.create()`

```python
>>> HeroInfo.objects.create(
    hname='沙悟净',
    gender=0,
    hbook=book
)
<HeroInfo: 沙悟净>  # 该方法有返回值.   创建好的模型对象
```

> 小结:
>
> 一、创建两种方式:
>
> - 1.save  三步走
> - 2.create .. 
>   - 关注:  外键关联字段,  传入对象  或  id

##### 2 查询

###### 2.1 基本查询

**get** 查询单一结果，如果不存在会抛出**`模型类.DoesNotExist`**异常。返回是 **对象**  

- 1.不同于 Flask 返回None;   所以需要 **异常捕获**
- 2.Flask中get只能传递 **id** , 而Django中不局限于id,且可以同时传递多个条件.
- 3. 如果存在多个结果, 则会报 `models.MultipleObjectsReturned` 错误

**all** 查询多个结果。   注: 不能传递条件

**count** 查询结果数量。

== 疑问:  为何没有提  `first()` 方法呢? ==

```python
>>> BookInfo.objects.all()
<QuerySet [<BookInfo: 射雕英雄传>, <BookInfo: 天龙八部>, <BookInfo: 笑傲江湖>, <BookInfo: 雪山飞狐>, <BookInfo: 西游记>]>
>>> book = BookInfo.objects.get(title='西游记')
>>> book.id
5

>>> BookInfo.objects.get(id=3)
<BookInfo: 笑傲江湖>
>>> BookInfo.objects.get(pk=3)
<BookInfo: 笑傲江湖>
>>> BookInfo.objects.get(id=100)
Traceback (most recent call last):
  File "<console>", line 1, in <module>
  File "/Users/delron/.virtualenv/dj/lib/python3.6/site-packages/django/db/models/manager.py", line 85, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
  File "/Users/delron/.virtualenv/dj/lib/python3.6/site-packages/django/db/models/query.py", line 380, in get
    self.model._meta.object_name
db.models.DoesNotExist: BookInfo matching query does not exist.

>>> BookInfo.objects.count()
6
```

###### 2.2 过滤查询

实现SQL中的where功能，包括

- **filter** 过滤出多个结果
  - 返回查询集, 即使只有一个结果也是查询集的形式, 可以用 `first`方法提取出来,再进行`save()`等操作, 防止报错.
- **exclude** 排除掉符合条件剩下的结果
- **get** 过滤单一结果          <u>*注: 不可聚合, 不可排序*</u>

对于过滤条件的

使用，上述三个方法相同，故仅以**filter**进行讲解。

过滤条件的表达语法如下：

```python
属性名称__比较运算符=值
# 属性名称和比较运算符间使用两个下划线，所以属性名不能包括多个下划线
```

**1）相等**

**exact：表示判等。**

例：查询编号为1的图书。

```django
BookInfo.objects.filter(id__exact=1)
可简写为：
BookInfo.objects.filter(id=1)
```

**2）模糊查询**

**contains：是否包含。**

> 说明：如果要包含%无需转义，直接写即可。

例：查询书名包含'传'的图书。

```python
BookInfo.objects.filter(title__contains='传')   # %传%
```

**startswith、endswith：以指定值开头或结尾。**

例：查询书名以'部'结尾的图书

```python
BookInfo.objects.filter(title__endswith='部')
```

> 以上运算符都区分大小写，在这些运算符前加上i表示不区分大小写，如iexact、icontains、istartswith、iendswith.

**3） 空查询**

**isnull：是否为null。**

例：查询书名不为空的图书。

```python
BookInfo.objects.filter(title__isnull=False)
```

**4） 范围查询**

**in：是否包含在范围内。**

例：查询编号为1或3或5的图书

```python
BookInfo.objects.filter(id__in=[1, 3, 5])  # 容器对象都可以, 不限列表
```

**5）比较查询**

- **gt** 大于 (greater then)
- **gte** 大于等于 (greater then equal)
- **lt** 小于 (less then)
- **lte** 小于等于 (less then equal)

例：查询编号大于3的图书

```python
BookInfo.objects.filter(id__gt=3)
```

**不等于的运算符，使用exclude()过滤器。**

例：查询编号不等于3的图书

```python
BookInfo.objects.exclude(id=3)
```

**6）日期查询**

**year、month、day、week_day、hour、minute、second：对日期时间类型的属性进行运算。**

例：查询1980年发表的图书。

```python
BookInfo.objects.filter(pub_date__year=1980)
```

例：查询1980年1月1日后发表的图书。

```python
BookInfo.objects.filter(pub_date__gt=date(1990, 1, 1))
```

###### F对象

> 提示:
>
> 多用于 update 场景

之前的查询都是**对象的属性与常量值比较**，两个属性怎么比较呢？ 答：使用F对象，被定义在`django.db.models`中。 

语法如下：

```
F(属性名)
```

例：查询阅读量大于等于评论量的图书。

```python
from django.db.models import F  #  filter -- F对象

BookInfo.objects.filter(read__gte=F('bcomment'))
```

**可以在F对象上使用算数运算。**

例：查询阅读量大于2倍评论量的图书。

```python
BookInfo.objects.filter(read__gt=F('comment') * 2)
```

###### Q对象

> 提示:
>
> `from django.db.models import Q`
>
> 实际上就是 `Query 类`,   然后多用于  查询条件比较复杂的场景可以来使用.如
>
> - `qs = Q(条件1)`  和 `qs2 = Q(条件2)` 等, 然后 `filter( qs | qs2)`

**多个过滤器逐个调用表示逻辑与关系，同sql语句中where部分的and关键字。**

例：查询阅读量大于20，并且编号小于3的图书。

```python
BookInfo.objects.filter(read__gt=20,id__lt=3)
或
BookInfo.objects.filter(read__gt=20).filter(id__lt=3)
```

**如果需要实现逻辑或or的查询，需要使用Q()对象结合|运算符**，Q对象被义在django.db.models中。

语法如下：

```
Q(属性名__运算符=值)
```

例：查询阅读量大于20的图书，改写为Q对象如下。

```python
from django.db.models import Q

BookInfo.objects.filter(Q(read__gt=20))
```

`Q对象可以使用&、|连接，&表示逻辑与，|表示逻辑或。`

例：查询阅读量大于20，或编号小于3的图书，只能使用Q对象实现

```python
BookInfo.objects.filter(Q(read__gt=20) | Q(pk__lt=3))
```

`Q对象前可以使用~操作符，表示非not`。

例：查询编号不等于3的图书。

```python
BookInfo.objects.filter(~Q(pk=3))
```

###### 聚合函数

使用aggregate()过滤器调用聚合函数。聚合函数包括：**Avg** 平均，**Count** 数量，**Max** 最大，**Min** 最小，**Sum** 求和，被定义在django.db.models中。

例：查询图书的总阅读量。

```python
from django.db.models import Sum

BookInfo.objects.aggregate(Sum('read'))
```

注意aggregate的返回值是一个**字典类型**，格式如下：

```python
  {'属性名__聚合方法小写':值}
  如:{'read__sum':3}
```

使用count时一般不使用aggregate()过滤器。

例：查询图书总数。

```python
BookInfo.objects.count()
```

注意count函数的返回值是一个数字。

###### 2.3 排序

使用**order_by**对结果进行排序

```python
BookInfo.objects.all().order_by('read')  # 升序
BookInfo.objects.all().order_by('-read', 'id')  # 降序
# 可以传入多个字段的排序.
```

###### 2.4 关联查询

由一到多的访问语法：

`一对应的模型类对象.多对应的模型类名小写_set` 例：

```python
b = BookInfo.objects.get(id=1)
b.heroinfo_set.all()
```

由多到一的访问语法:

`多对应的模型类对象.多对应的模型类中的关系类属性名` 例：

```python
h = HeroInfo.objects.get(id=1)
h.hbook
```

访问一对应的模型类关联对象的id语法:

`多对应的模型类对象.关联类属性_id`

例：

```python
h = HeroInfo.objects.get(id=1)
h.hbook_id
```

###### 关联过滤查询

**由多模型类条件查询一模型类数据**:

语法如下：

```python
关联模型类名小写__属性名__条件运算符=值
```

**注意：如果没有"__运算符"部分，表示等于。**

例：

查询图书，要求图书英雄为"孙悟空"

```python
BookInfo.objects.filter(heroinfo__hname='孙悟空')
```

查询图书，要求图书中英雄的描述包含"八"

```python
BookInfo.objects.filter(heroinfo__hcomment__contains='八')
```

**由一模型类条件查询多模型类数据**:

语法如下：

```python
一模型类关联属性名__一模型类属性名__条件运算符=值
# 备注一下:
一模型类关联属性名 指代的是 多模型类中的外键关联(一模型类)的那个属性
```

**注意：如果没有"__运算符"部分，表示等于。**

例：

查询书名为“天龙八部”的所有英雄。

```python
HeroInfo.objects.filter(hbook__title='天龙八部')
```

查询图书阅读量大于30的所有英雄

```python
HeroInfo.objects.filter(hbook__read__gt=30)
```

> 小结:
>
> ​	通俗的记忆就是, 一对多 或 多对一 在语法上都是**一个模型类作为"查询的基准"**,另外一个作为过滤条件. 其中,  如果**过滤条件**可以写`外键关联属性`的用属性, 没有外键关联的属性的就用 `模型类小写`

##### 3 修改

修改更新有两种方法

**1）save**

**修改模型类对象的属性，然后执行save()方法**

```python
hero = HeroInfo.objects.get(hname='猪八戒')
hero.hname = '猪悟能'
hero.save()
```

**2）update**

**使用模型类.objects.filter().update()**，会返回受影响的行数

```python
HeroInfo.objects.filter(hname='沙悟净').update(hname='沙僧', id=100)  # 支持多个同时修改, 联系原生的 sql 语句 理解.
```

> 小结:
>
> `save`方法中使用的是 `get` 过滤, 因为get返回的是单个模型类对象,使用 `filter` 返回的是 **QuerySet** 会报错;  当然可以在 `filter()`方法后面再接`first()` 方法即可.
>
> `update` 方法中使用 `filter`过滤, 返回查询结果集, 所以会返回受影响的行数.
>
> 注:
>
> 第一种方式**进行了两次操作:先查询再修改**,  所以更多的时候 更加推荐 第二种.

> 重要补充:
>
> #### 更新  与  F  (F对象实现数据批量修改)
>
> `BookInfo.objects.all().update(read = F('read') + 1000 )` 将每本书的阅读量增加 1000.
>
> 这里可以使用  `for q in qs: `来实现, 但是 性能太差.

##### 4 删除

删除有两种方法

**1）模型类对象.delete**

```python
hero = HeroInfo.objects.get(id=13)
hero.delete()  # 其实可以直接链式操作.
```

**2）模型类.objects.filter().delete()**

```python
HeroInfo.objects.filter(id=14).delete()
```

> 小结:
>
> 返回的都是:   `(1, {'booktest.HeroInfo': 1})`  影响的行数是1 

##### 5 补充`__str__`方法

> 使得返回的查询集结果更加人性化,  使得admin站点中的查询结果更加人性化

```python
class BookInfo(models.Model):
    ...
    ...
    def __str__(self):
        return self.title
```



#### 5.5 查询集 `QuerySet`

##### 1 概念

Django的ORM中存在查询集的概念。

查询集，也称查询结果集、`QuerySet`，表示从数据库中获取的对象集合。

**当调用如下过滤器方法时，Django会返回查询集（而不是简单的列表）：**

> - all()：返回所有数据。
> - filter()：返回满足条件的数据。
> - exclude()：返回满足条件之外的数据。
> - order_by()：对结果进行排序。

对查询集可以再次调用过滤器进行过滤，如

```python
BookInfo.objects.filter(read__gt=30).order_by('pub_date')
```

也就意味着查询集可以含有零个、一个或多个过滤器。过滤器基于所给的参数限制查询的结果。

**从SQL的角度讲，查询集与select语句等价，过滤器像where、limit、order by子句。**

**判断某一个查询集中是否有数据**：

- exists()：判断查询集中是否有数据，如果有则返回True，没有则返回False。

##### 2 两大特性

###### 1）惰性执行

**创建查询集不会访问数据库，直到调用数据时，才会访问数据库，调用数据的情况包括迭代、序列化、与if合用**

例如，当执行如下语句时，并未进行数据库查询，只是创建了一个查询集qs

```python
qs = BookInfo.objects.all()
```

继续执行遍历迭代操作后，才真正的进行了数据库的查询

```python
for book in qs:
    print(book.title)
```

###### 2）缓存

**使用同一个查询集，第一次使用时会发生数据库的查询，然后Django会把结果缓存下来，再次使用这个查询集时会使用缓存的数据，减少了数据库的查询次数。**

**情况一**：如下是两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互，增加了数据库的负载。

```python
from booktest.models import BookInfo
[book.id for book in BookInfo.objects.all()]
[book.id for book in BookInfo.objects.all()]
```

![两个查询集](./img_django/queryset_uncache.png)

![两次查询](./img_django/queyrset_uncache_result.png)

**情况二**：**经过存储后**，可以重用查询集，第二次使用缓存中的数据。

```python
qs=BookInfo.objects.all()
[book.id for book in qs]
[book.id for book in qs]
```

![一个查询集](./img_django/queryset_cache.png)

![一次查询](./img_django/queryset_cache_result.png)

##### 3 限制查询集

可以对查询集进行取下标或切片操作，等同于sql中的limit和offset子句。

> 注意：不支持负数索引。

**对查询集进行切片后返回一个新的查询集，不会立即执行查询。**

如果获取一个对象，直接使用[0]，等同于[0:1].get()，但是如果没有数据，[0]引发IndexError异常，[0:1].get()如果没有数据引发DoesNotExist异常。

示例：获取第1、2项，运行查看。

```python
qs = BookInfo.objects.all()[0:2]
```



#### 5.6 管理器Manager

管理器是Django的模型进行数据库操作的接口，Django应用的每个模型类都拥有至少一个管理器。

我们在通过模型类的**objects**属性提供的方法操作数据库时，即是在使用一个管理器对象objects。当没有为模型类定义管理器时，Django会为每一个模型类生成一个名为objects的管理器，它是**models.Manager**类的对象。即, `objects = models.Manager()` 

##### 自定义管理器

我们可以自定义管理器，并应用到我们的模型类上。

**注意：一旦为模型类指明自定义的过滤器后，Django不再生成默认管理对象objects。**

自定义管理器类主要用于两种情况：

**1. 修改原始查询集，重写all()方法。**

a）打开booktest/models.py文件，定义类BookInfoManager

```python
#图书管理器
class BookInfoManager(models.Manager):
    def all(self):
        #默认查询未删除的图书信息
        #调用父类的成员语法为：super().方法名
        return super().filter(is_delete=False)
```

b）在模型类BookInfo中定义管理器

```
class BookInfo(models.Model):
    ...
    books = BookInfoManager()
```

c）使用方法

```python
BookInfo.books.all()
```

**2. 在管理器类中补充定义新的方法**

a）打开booktest/models.py文件，定义方法create。

```python
class BookInfoManager(models.Manager):
    #创建模型类，接收参数为属性赋值
    def create_book(self, title, pub_date):
        #创建模型类对象self.model可以获得模型类
        book = self.model()
        book.title = title
        book.pub_date = pub_date
        book.read=0
        book.bcommet=0
        book.is_delete = False
        # 将数据插入进数据表
        book.save()
        return book
```

b）为模型类BookInfo定义管理器books语法如下

```
class BookInfo(models.Model):
      ...
    books = BookInfoManager()
```

c）调用语法如下：

```python
book=BookInfo.books.create_book("abc",date(1980,1,1))
```





---



### 6. 模板使用

#### 1 配置

在工程中创建模板目录templates, 如果是在pycharm中还可以配置模板目录。

在settings.py配置文件中修改**TEMPLATES**配置项的DIRS值：

```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],  # 此处修改模板目录
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```

#### 2 定义模板

在templates目录中新建一个模板文件，如index.html

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h1>{{ city }}</h1>
</body>
</html>
```

#### 3 模板渲染

调用模板分为两步：

1. **找到模板** loader.get_template(**模板文件在模板目录中的相对路径**) -> 返回模板对象
2. **渲染模板** 模板对象.render(context=None, request=None) -> 返回渲染后的html文本字符串 context 为模板变量字典，默认值为None request 为请求对象，默认值为None

例如，定义一个视图

```python
from django.http import HttpResponse
from django.template import loader

def index(request):
    # 1.获取模板
    template=loader.get_template('index.html')  # 相对路径
	
    context={'city': '北京'}
    # 2.渲染模板
    return HttpResponse(template.render(context))
---
存疑:  两个版本, 下面是分为三步的:
---
def index(request):
    # 1.获取模板
    template = loader.get_template("booktest/index.html")
    # 2.定义上下文
    context = RequestContext(request, {'city': '北京'})
    # 3.渲染模板
    return HttpResponse(template.render(context))
```

**Django提供了一个函数render可以简写上述代码。**

render(request对象, 模板文件路径, 模板数据字典)

```python
from django.shortcuts import render

def index(request):
    context={'city': '北京'}
    return render(request,'index.html',context)
```

#### 4 模板语法

##### 4.1 模板变量

变量名必须由字母、数字、下划线（不能以下划线开头）和点组成。

语法如下：

```python
{{变量}}
```

模板变量可以使python的内建类型，也可以是对象。

```python
def index(request):
    context = {
        'city': '北京',
        'adict': {
            'name': '西游记',
            'author': '吴承恩'
        },
        'alist': [1, 2, 3, 4, 5]
    }
    return render(request, 'index.html', context)
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h1>{{ city }}</h1>
    <h1>{{ adict }}</h1>
    <h1>{{ adict.name }}</h1>  注意字典的取值方法
    <h1>{{ alist }}</h1>  
    <h1>{{ alist.0 }}</h1>  注意列表的取值方法
</body>
</html>
```

##### 4.2 模板语句

**1）for循环：**

```python
{% for item in 列表 %}

循环逻辑
{{forloop.counter}}表示当前是第几次循环，从1开始
{%empty%} 列表为空或不存在时执行此逻辑

{% endfor %}
```

**2）if条件：**

```python
{% if ... %}
逻辑1
{% elif ... %}
逻辑2
{% else %}
逻辑3
{% endif %}
```

比较运算符如下：

```
==
!=
<
>
<=
>=
```

布尔运算符如下：

```
and
or
not
```

**注意：运算符左右两侧不能紧挨变量或常量，必须有空格。**

```python
{% if a == 1 %}  # 正确
{% if a==1 %}  # 错误
```

##### 4.3 过滤器

语法如下:

- 使用管道符号|来应用过滤器，用于进行计算、转换操作，可以使用在变量、标签中。

- 如果过滤器需要参数，则使用冒号:传递参数。

  ```python
  变量|过滤器:参数
  ```

列举几个如下：

- **safe**，禁用转义，告诉模板这个变量是安全的，可以解释执行

- **length**，长度，返回字符串包含字符的个数，或列表、元组、字典的元素个数。

- **default**，默认值，如果变量不存在时则返回默认值。

  ```
  data|default:'默认值'
  ```

- **date**，日期，用于对日期类型的值进行字符串格式化，常用的格式化字符如下：

  - Y表示年，格式为4位，y表示两位的年。
  - m表示月，格式为01,02,12等。
  - d表示日, 格式为01,02等。
  - j表示日，格式为1,2等。
  - H表示时，24进制，h表示12进制的时。
  - i表示分，为0-59。
  - s表示秒，为0-59。

  ```
  value|date:"Y年m月j日  H时i分s秒"
  ```

##### 4.4 注释

1）单行注释语法如下：

```
{#...#}
```

2）多行注释使用comment标签，语法如下：

```python
{% comment %}
...
{% endcomment %}
```

##### 4.5 模板继承

模板继承和类的继承含义是一样的，主要是为了提高代码重用，减轻开发人员的工作量。

**父模板**

如果发现在多个模板中某些内容相同，那就应该把这段内容定义到父模板中。

标签block：用于在父模板中预留区域，留给子模板填充差异性的内容，名字不能相同。 为了更好的可读性，建议给endblock标签写上名字，这个名字与对应的block名字相同。父模板中也可以使用上下文中传递过来的数据。

```python
{% block 名称 %}
预留区域，可以编写默认内容，也可以没有默认内容
{% endblock  名称 %}
```

**子模板**

标签extends：继承，写在子模板文件的第一行。

```
{% extends "父模板路径"%}
```

子模版不用填充父模版中的所有预留区域，如果子模版没有填充，则使用父模版定义的默认值。

填充父模板中指定名称的预留区域。

```
{% block 名称 %}
实际填充内容
{{ block.super }}用于获取父模板中block的内容
{% endblock 名称 %}
```



### 7. 表单 使用

Django提供对表单处理的原生支持，可以简化并自动化大部分的表单处理工作。

#### 7.1 定义表单类

**表单系统的核心部分是Django 的Form类。** Django 的数据库模型描述一个对象的逻辑结构、行为以及展现给我们的方式，与此类似，Form类描述一个表单并决定它如何工作和展现。

> 个人理解: 类似drf框架的序列化器的验证的思路, 可以进行相应的校验.

假如我们想在网页中创建一个表单，用来获取用户想保存的图书信息，可能类似的html 表单如下：

```html
<form action="" method="post">
    <input type="text" name="title">
    <input type="date" name="pub_date">
    <input type="submit">
</form>
```

我们可以据此来创建一个Form类来描述这个表单。

新建一个**forms.py**文件，编写Form类。

```python
from django import forms

class BookForm(forms.Form):  # 继承自 Form 类
    title = forms.CharField(label="书名", required=True, max_length=50)
    pub_date = forms.DateField(label='出版日期', required=True)

# 类比  序列化器
```

注：[表单字段类型参考资料连接](https://yiyibooks.cn/xx/Django_1.11.6/ref/forms/fields.html)

#### 7.2 视图中使用表单类

```python
from django.shortcuts import render
from django.views.generic import View
from django.http import HttpResponse

from .forms import BookForm

class BookView(View):
    def get(self, request):
        form = BookForm()
        return render(request, 'book.html', {'form': form})

    def post(self, request):
        form = BookForm(request.POST)
        if form.is_valid():  # 验证表单数据
            print(form.cleaned_data)  # 获取验证后的表单数据
            return HttpResponse("OK")
        else:  # 如果验证不通过, 那么渲染返回的时候也会有错误信息
            return render(request, 'book.html', {'form': form})
```

- form.is_valid() 验证表单数据的合法性
- form.cleaned_data 验证通过的表单数据

#### 7.3 模板中使用表单类

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>书籍</title>
</head>
<body>
    <form action="" method="post">
        {% csrf_token %}
        {{ form }}  # 直接接收表单实例, 可以自动处理.
        <input type="submit">  // 这一行需要自己补充
    </form>
</body>
</html>

// 浏览器自己也带验证功能, 对于表单的字段也是必须提交.这个时候的验证并未发送POST请求.
```

- csrf_token 用于添加CSRF防护的字段
- form 快速渲染表单字段的方法

> #### 表单优点:
>
> - 1.可以定义表单类, 并进行表单的验证操作.
> - 2.简化语法: 在 模板中 只需要插入 `{ form }` 即可实现表单.

#### 7.4 模型类表单

如果表单中的数据与模型类对应，可以通过继承**forms.ModelForm**更快速的创建表单。

```python
class BookForm(forms.ModelForm):   # 类比: 序列化器
    class Meta:
        model = BookInfo
        fields = ('btitle', 'bpub_date')
```

- model 指明从属于哪个模型类
- fields 指明向表单中添加模型类的哪个字段



### 8. admin 站点

#### 8.1 使用Admin站点

假设我们要设计一个新闻网站，我们需要编写展示给用户的页面，网页上展示的新闻信息是从哪里来的呢？**是从数据库中查找到新闻的信息，然后把它展示在页面上**。但是我们的网站上的新闻每天都要更新，这就意味着对数据库的增、删、改、查操作，那么我们需要每天写sql语句操作数据库吗? 如果这样的话，是不是非常繁琐，所以我们可以设计一个页面，通过对这个页面的操作来实现对新闻数据库的增删改查操作。那么问题来了，老板说我们需要在建立一个新网站，是不是还要设计一个页面来实现对新网站数据库的增删改查操作，但是这样的页面具有一个很大的重复性，那有没有一种方法能够让我们很快的生成管理数据库表的页面呢？**有，那就是我们接下来要给大家讲的Django的后台管理**。Django能够根据定义的模型类自动地生成管理页面。

**使用Django的管理模块，需要按照如下步骤操作：**

1. **管理界面本地化**
2. **创建管理员**
3. **注册模型类**
4. **自定义管理页面**

##### 1 管理界面本地化

在settings.py中设置语言和时区

```python
LANGUAGE_CODE = 'zh-hans' # 使用中国语言
TIME_ZONE = 'Asia/Shanghai' # 使用中国上海时间
```

##### 2 创建超级管理员

创建管理员的命令如下，按提示输入用户名、邮箱、密码。

```shell
python manage.py createsuperuser
```

打开浏览器，在地址栏中输入如下地址后回车。

```html
http://127.0.0.1:8000/admin/
```

输入前面创建的用户名、密码完成登录。

登录成功后界面如下，但是并没有我们自己应用模型的入口，接下来进行第三步操作。

##### 3 注册模型类

登录后台管理后，默认没有我们创建的应用中定义的模型类，需要在自己应用中的admin.py文件中注册，才可以在后台管理中看到，并进行增删改查操作。

打开booktest/admin.py文件，编写如下代码：

```python
from django.contrib import admin
from booktest.models import BookInfo,HeroInfo

admin.site.register(BookInfo)
admin.site.register(HeroInfo)
```

到浏览器中刷新页面，可以看到模型类BookInfo和HeroInfo的管理了。

![注册成功](./img_django/register_success.png)

点击类名称"BookInfo"（图书）可以进入列表页，默认只有一列。

![列表页](./img_django/admin_list.png)

在列表页中点击"增加"可以进入增加页，Django会根据模型类的不同，生成不同的表单控件，按提示填写表单内容后点击"保存"，完成数据创建，创建成功后返回列表页。

![添加页](./img_django/admin_add.png)

在列表页中点击某行的第一列可以进入修改页。

![修改页1](./img_django/admin_update_enter.png)

按照提示进行内容的修改，修改成功后进入列表页。在修改页点击“删除”可以删除一项。

![修改页2](./img_django/admin_update.png)

删除：在列表页勾选想要删除的复选框，可以删除多项。

![删除1](./img_django/admin_delete.png)

点击执行后进入确认页面，删除后回来列表页面。

![删除2](./img_django/admin_delete_check.png)

##### 4 定义与使用Admin管理类

Django提供的Admin站点的展示效果可以通过自定义**ModelAdmin**类来进行控制。

定义管理类需要继承自**admin.ModelAdmin**类，如下

```python
from django.contrib import admin

class BookInfoAdmin(admin.ModelAdmin):
    pass
```

使用管理类有两种方式：

- 注册参数

  ```python
  admin.site.register(BookInfo,BookInfoAdmin)  # admin.site 对象指向了 admin的管理界面
  ```

- 装饰器

  ```python
  @admin.register(BookInfo)
  class BookInfoAdmin(admin.ModelAdmin):
      pass
  ```





#### 8.2 调整列表页展示

##### 1 页大小

每页中显示多少条数据，默认为每页显示100条数据，属性如下：

```python
list_per_page=100
```

1）打开booktest/admin.py文件，修改AreaAdmin类如下：

```python
class BookInfoAdmin(admin.ModelAdmin):
    list_per_page = 2
```

2）在浏览器中查看区域信息的列表页面，效果如下图：

![列表页选项](./img_django/list_option.png)

##### 2 "操作选项"的位置

顶部显示的属性，设置为True在顶部显示，设置为False不在顶部显示，默认为True。

```python
actions_on_top=True
```

底部显示的属性，设置为True在底部显示，设置为False不在底部显示，默认为False。

```python
actions_on_bottom=False
```

1）打开booktest/admin.py文件，修改BookInfoAdmin类如下：

```python
class BookInfoAdmin(admin.ModelAdmin):
    ...
    actions_on_top = True
    actions_on_bottom = True
```

2）在浏览器中刷新效果如下图：

![列表页选项](./img_django/list_option_top.png)

##### 3 列表中的列

属性如下：

```
list_display=[模型字段1,模型字段2,...]
```

1）打开booktest/admin.py文件，修改BookInfoAdmin类如下：

```python
class BookInfoAdmin(admin.ModelAdmin):
    ...
    list_display = ['id','btitle']
```

2）在浏览器中刷新效果如下图：

![列表页选项](./img_django/list_option_col.png)

**点击列头可以进行升序或降序排列。**

##### 4 将方法作为列

列可以是模型字段，还可以是模型方法，要求方法有返回值。

**通过设置short_description属性，可以设置在admin站点中显示的列名。**

1）打开booktest/models.py文件，修改BookInfo类如下：

```python
class BookInfo(models.Model):
    ...
    def pub_date(self):
        return self.bpub_date.strftime('%Y年%m月%d日')

    pub_date.short_description = '发布日期'  # 设置方法字段在admin中显示的标题
```

2）打开booktest/admin.py文件，修改BookInfoAdmin类如下：

```python
class BookInfoAdmin(admin.ModelAdmin):
    ...
    list_display = ['id','atitle','pub_date']
```

3）在浏览器中刷新效果如下图：

![列表页选项](./img_django/list_option_method_col.png)

方法列是不能排序的，如果需要排序需要为方法指定排序依据。

```
admin_order_field=模型类字段
```

1）打开booktest/models.py文件，修改BookInfo类如下：

```python
class BookInfo(models.Model):
    ...
    def pub_date(self):
        return self.bpub_date.strftime('%Y年%m月%d日')

    pub_date.short_description = '发布日期'
    pub_date.admin_order_field = 'bpub_date'
```

2）在浏览器中刷新效果如下图：

![列表页选项](./img_django/admin_order_filed.png)

##### 5 关联对象

无法直接访问关联对象的属性或方法，可以在模型类中封装方法，访问关联对象的成员。

1）打开booktest/models.py文件，修改HeroInfo类如下：

```python
class HeroInfo(models.Model):
    ...
    def read(self):
        return self.hbook.bread

    read.short_description = '图书阅读量'
```

2）打开booktest/admin.py文件，修改HeroInfoAdmin类如下：

```python
class HeroInfoAdmin(admin.ModelAdmin):
    ...
    list_display = ['id', 'hname', 'hbook', 'read']
```

3）在浏览器中刷新效果如下图：

![列表页选项](./img_django/list_relate_obj.png)

##### 6 右侧栏过滤器

属性如下，只能接收字段，会将对应字段的值列出来，用于快速过滤。一般用于有重复值的字段。

```
list_filter=[]
```

1）打开booktest/admin.py文件，修改HeroInfoAdmin类如下：

```python
class HeroInfoAdmin(admin.ModelAdmin):
    ...
    list_filter = ['hbook', 'hgender']
```

2）在浏览器中刷新效果如下图：

![列表页选项](./img_django/admin_filter.png)

##### 7 搜索框

属性如下，用于对指定字段的值进行搜索，支持模糊查询。列表类型，表示在这些字段上进行搜索。

```
search_fields=[]
```

1）打开booktest/admin.py文件，修改HeroInfoAdmin类如下：

```python
class HeroInfoAdmin(admin.ModelAdmin):
    ...
    search_fields = ['hname']
```

2）在浏览器中刷新效果如下图：

![列表页选项](./img_django/list_search.png)



#### 8.3 调整编辑页展示

##### 1. 显示字段

属性如下：

```
fields=[]
```

1）点击某行ID的链接，可以转到修改页面，默认效果如下图：

![编辑页选项](./img_django/edit_default.png)

2）打开booktest/admin.py文件，修改BookInfoAdmin类如下：

```python
class BookInfoAdmin(admin.ModelAdmin):
    ...
    fields = ['btitle', 'bpub_date']
```

3）刷新浏览器效果如下图：

![编辑页选项](./img_django/edit_result.png)

##### 2. 分组显示

属性如下：

```
fieldset=(
    ('组1标题',{'fields':('字段1','字段2')}),
    ('组2标题',{'fields':('字段3','字段4')}),
)
```

1）打开booktest/admin.py文件，修改BookInfoAdmin类如下：

```python
class BookInfoAdmin(admin.ModelAdmin):
    ...
    # fields = ['btitle', 'bpub_date']
    fieldsets = (
        ('基本', {'fields': ['btitle', 'bpub_date']}),
        ('高级', {
            'fields': ['bread', 'bcomment'],
            'classes': ('collapse',)  # 是否折叠显示
        })
    )
```

2）刷新浏览器效果如下图：

![编辑页选项](./img_django/display_group.png)

> 说明：fields与fieldsets两者选一使用。

##### 3. 关联对象

在一对多的关系中，可以在一端的编辑页面中编辑多端的对象，嵌入多端对象的方式包括表格、块两种。

- 类型InlineModelAdmin：表示在模型的编辑页面嵌入关联模型的编辑。
- 子类TabularInline：以表格的形式嵌入。
- 子类StackedInline：以块的形式嵌入。

1）打开booktest/admin.py文件，创建HeroInfoStackInline类。

```python
class HeroInfoStackInline(admin.StackedInline):
    model = HeroInfo  # 要编辑的对象
    extra = 1  # 附加编辑的数量
```

2）打开booktest/admin.py文件，修改BookInfoAdmin类如下：

```python
class BookInfoAdmin(admin.ModelAdmin):
    ...
    inlines = [HeroInfoStackInline]
```

3）刷新浏览器效果如下图：

![编辑页选项](./img_django/relate_obj.png)

可以用表格的形式嵌入。

1）打开booktest/admin.py文件，创建HeroInfoTabularInline类。

```python
class HeroInfoTabularInline(admin.TabularInline):
    model = HeroInfo
    extra = 1
```

2）打开booktest/admin.py文件，修改BookInfoAdmin类如下：

```python
class BookInfoAdmin(admin.ModelAdmin):
    ...
    inlines = [HeroInfoTabularInline]
```

3）刷新浏览器效果如下图：

![编辑页选项](./img_django/relate_table.png)



#### 8.4 调整站点信息

Admin站点的名称信息也是可以自定义的。

未调整前如下图：

![原始admin站点](./img_django/origin_site.png)

- **admin.site.site_header** 设置网站页头
- **admin.site.site_title** 设置页面标题
- **admin.site.index_title** 设置首页标语

在booktest/admin.py文件中添加一下信息

```python
from django.contrib import admin

admin.site.site_header = '传智书城'
admin.site.site_title = '传智书城MIS'
admin.site.index_title = '欢迎使用传智书城MIS'
```

刷新网站，效果如下

![调整后的admin站点](./img_django/modified_admin_site.png)



#### 8.5 上传图片

Django有提供文件系统支持，在Admin站点中可以轻松上传图片。

使用Admin站点保存图片，需要安装Python的图片操作包

```python
pip install Pillow
```

##### 1 配置

默认情况下，Django会将上传的图片保存在本地服务器上，需要配置保存的路径。

我们可以将上传的文件保存在静态文件目录中，如我们之前设置的static_files目录中在settings.py 文件中添加如下上传保存目录信息

```python
MEDIA_ROOT=os.path.join(BASE_DIR,"static_files/media")
```

##### 2 为模型类添加ImageField字段

我们为之前的BookInfo模型类添加一个ImageFiled

```python
class BookInfo(models.Model):
    ...
    image = models.ImageField(upload_to='booktest', verbose_name='图片', null=True)
```

- upload_to 选项指明该字段的图片保存在MEDIA_ROOT目录中的哪个子目录

进行数据库迁移操作

```python
python manage.py makemigrations
python manage.py migrate
```

##### 3 使用Admin站点上传图片

进入Admin站点的图书管理页面，选择一个图书，能发现多出来一个上传图片的字段

![admin站点图片字段](./img_django/admin_image.png)

选择一张图片并保存后，图片会被保存在**static_files/media/booktest/**目录下。

在数据库中，我们能看到image字段被设置为图片的路径

![图片字段](./img_django/image_field_data.png)


























































































































### 2. 业务逻辑(模块)





#### 1.用户

##### 1.1注册

- 图片验证码
  - 业务描述
- 短信验证码
  - 业务描述
  - 技术: redis管道
  - 技术: celery异步任务
- 用户名是否存在判断
- 手机号是否存在判断
- 注册保存用户数据
  - 技术:序列化器获取视图对象
    - self.context[request] 
    - self.context[ view] 
    - self.context[format] 
  - 技术:视图对象中的方法--获取视图参数
    - self.request
    - self.args  `/demo/(\d+)/`
    - self.kwargs  `/demo/(?P<order_id>\d+)/`
  - 保存用户的登陆状态:
    - session
    - jwt
      - token机制
      - token机制的流程
        - 签发
        - 验证
      - 构成
        - 头部  header
        - 载荷  payload
        - 签名  sign
      - 优点和注意事项
        - 优点: ?????
        - 注意: payload不放敏感数据
      - 适用的场景:    `前后端分离的场景`
      - drf中的实现:   引入扩展`djangorestframework-jwt`扩展

##### 1.2登陆

- 登陆
  - 技术: `djangorestframework-jwt`扩展提供了登陆处理视图
  - 技术: django中多种账号类型的登陆:
    - 构造 `ModelBackend` 的子类
    - 实现 `authenticate` 

##### 1.3找回密码

##### 1.4三方登录(QQ登陆)

- 业务:实现QQ登录的处理时序图能够描述清楚

- 技术: 工具类的封装: `SDK`  

  - 类的构造实现 
    - 思路: 1.先考虑使用场景; 2.用什么就添加什么
    - 属性和方法的选择 

- 技术: urllib

  - 1.python标准模块

  - 2.作用: 主要用python程序向外发送 http请求

  - 3.常用模块

    ```python
    urllib.parse.urlencode
    urllib.parse.parse_qs
    urllib.request.urlopen
    ```
```

- 技术:itsdangerous

##### 1.5个人中心

- 展示个人信息
- 邮箱验证
  - 业务
    -  保存邮箱并发送邮件
    - 邮箱验证链接
  - 技术
    - 发送邮件
      - 流程:  依赖邮箱服务器
      - django发送邮件的方法:  `send_mail`
    - 生成验证链接
      - 使用itsdangerous模块生成验证链接参数(包含用户的身份)
    - 使用celery异步发送邮件

##### 1.6邮件发送与认证

##### 1.7用户地址

- 业务  
  - 省市区三级联动
  - 用户地址管理
    - 增删改查
    - 默认地址
    - 地址标题
- 技术
  - 省市区可以用一张自关联的表保存
  - django中如何实现自关联(models.Model  -> ForeignKey  -> 'self')
  - 缓存
    - 作用: 减少数据库的查询次数
    - 原理: 1.先查询缓存; 2.如果缓存中没有数据查询数据库,并保存到缓存中; 3.如果缓存中有数据,直接读取并返回; 4. ==注意:== 缓存要设置有效期
    - drf使用缓存的方法:  (引入: `drf-extensions扩展` )
      - 装饰器
      - 扩展类继承
  - drf视图集的使用

##### 1.8用户浏览记录

- 业务
  - 浏览商品详情页记录浏览历史
  - 个人中心   产看浏览历史
- 技术
  - redis数据类型的选择
    - str  单一的数据
    - list  一组数据  有顺序  无去重
    - set  一组数据  无序  去重
    - hash  一组键值对数据
      - 不同于python中的字典
      - 键和值都是字符串
  - 浏览历史纪录   使用 list 保存

##### 1.9修改密码



#### 2.商品

##### <u>商品--前台部分--给消费者用户使用</u>

##### 2.1 首页广告

- 业务:广告数据
- 技术:页面静态化

##### 2.2 商品详情页

- 业务: 一部分静态化,一部分动态请求
- 技术: admin站点数据修改时静态化
  - django中如何向admin站点保存数据时添加自定义地逻辑
    - 自定义admin管理器
    - save_model
    - delete_model
  - 使用celery执行静态化地异步任务

##### 2.3 列表页

- 业务
- 技术
  - drf的列表视图中如何实现排序和分页

##### 2.4 搜索页

- 业务
- 技术: 搜索引擎

##### <u>商品--后台部分--公司内部运营人员使用</u>

##### 2.5 商品数据管理

- 技术
  - 概念:  SPU  SKU
  - 数据库的设计思路
    - 分析产品的原型图,明确要保存哪些数据
    - 分析中心(核心)数据
    - 确定中心数据需要保存哪些字段
    - 分析要保存的字段中,哪些可以保存到中心数据表中,哪些不合适保存到当前表,需要另建表保存.
    - 在确定了表和关系之后,确定了保存的基本数据,还要考虑使用数据库的查询方便与否
    - 考虑数据库在编程的时候的应用场景,是否可以通过添加冗余字段,减少数据库的查询时间
  - FastDFS  -- 图片保存

#### 3.购物车

- 业务
  - 3.1 登陆与未登陆的数据(状态)保存
  - 3.2 增
  - 3.3 删
  - 3.4 改
  - 3.5 查
  - 3.6 全选|反选
  - 3.6 合并购物车
- 技术
  - 登录   redis   
    - hash  数量
    - set  勾选状态
  - 未登录  cookie
    - 将购物车数据转换成字符串保存到cookie中
    - pickle
      - dumps
      - loads
    - base64
      - b64encode
      - b64decode
  - 登录合并
    - 修改jwt扩展提供的登录视图,补充合并逻辑



#### 4.订单

业务

- 4.1 订单结算(确认提交订单页面)
  - 数据来源于购物车redis的查询

- 4.2 保存订单

- 4.3 我的订单

- 4.4 订单评论

技术

- 事务
  - 作用
    - 保证数据的完整性,一些列相关的数据库操作一起成功或失败
    - Django当中的使用方式:  
      - 提供`transaction模块`
      - atomic
        - 装饰器
        - with
      - save_point
- 并发请求
  - 现象: 商品超卖(超库存)
  - 原因: 多个请求同时修改同一数据资源(资源竞争)
  - 解决方法
    - 悲观锁  :  数据库中真实存在的数据锁   -  死锁
    - 乐观锁  :  在更新时增加判断的逻辑
    - 任务队列  :  强制排队,将并行的请求串行化
- 数据库事务隔离级别
  - read  uncommit  读未提交
  - read   commited   读取已提交
  - repeated  read  可重复读
  - serialize  串行化
  - 解决: 在一个事务中读取的数据是否受到其它事务修改的影响



#### 5.支付

##### 5.1 第三方支付(支付宝支付)

业务

获取支付链接

保存支付结果

技术

调用支付宝的支付接口流程

#### 6.运营后台

技术

xadmin

- 增强了django原生的admin功能
- 使用方法

用户权限控制

- 作用: 不同的用户在admin站点中可以读取或修改哪些数据
- django的认证系统自带实现
- 用户权限 = 组权限 +  用户特有权限
- 借鉴意义: 通过6张表实现





### 技术选型

##### redis管道

- 1.减少程序与redis之间通信的网络消耗

- 2.管道收集了redis的命令,一次性发送给redis服务器执行

- 3.使用方法:

  ```python
  pl = pipeline()
  pl.xxx  # 命令同redis命令   那种类型的命令???
  pl.execute()   
  # 管道其实有点类似: '事务'
```

##### 跨域请求及解决

- 定义: 不同的域发起的请求

- `域(源)`的概念:

  - 域名  或  ip
  - 端口号
  - 协议  http   https

- 后端解决方式 `CORS` 

  - 具体思路:

    - 1.浏览器会先发送option请求,询问后端是否支持当前域名的跨域请求

    - 2.后端支持处理option请求,返回'同意'的响应

    - 3.思考如何在 Flask 项目中实现???

  - django的解决方式:

    - 1.在中间键中 处理option 
    - 2.使用  `django-cors-headers` 扩展来实现

##### JWT

##### itsdangerous(不用反映在简历中）

- 作用:生成token, 在token中保存隐藏一些数据,如果前端修改了token中的数据,可以通过校验识别错误的token
- `token`中包含了 **有效期** 和 **签名**
- 使用方法:
  - 创建对象
  - dumps
  - loads
- 应用场景: 1. 需要传递一些数据到前端,而且这些数据我们期望隐藏传递; 2.并且前端如果对这些数据进行了修改,我们还能通过校验发现.

```python
from itsdangerous import TimedJSONWebSignatureSerializer as Serializer  # 注意:别名
from django.conf import settings

# serializer = Serializer(秘钥, 有效期秒)
serializer = Serializer(settings.SECRET_KEY, 300)
# serializer.dumps(数据), 返回bytes类型
token = serializer.dumps({'mobile': '18512345678'})
token = token.decode()  # bytes 解码

# 检验token
# 验证失败，会抛出itsdangerous.BadData异常
serializer = Serializer(settings.SECRET_KEY, 300)
try:
    data = serializer.loads(token)  # 字符串来解析成token, 过程中会进行校验
except BadData:
    return None
```



##### 第三方登录

##### 发送邮件与邮件激活

##### 缓存

##### Celery

- 作用: 将耗时任务交给celery执行, 减少视图响应时间
- 构成: client(任务发布程序), broker(任务队列), worker(任务执行者)
- 工作流程(运行原理)
- 使用方式
  - 定义任务   `@celery_app.task`   
  - 发布任务   `delay(可以传递参数)`
  - 启动worker   `celery -A  celery入口文件  -i worker 执行文件`
- 什么时候使用:  有需要将耗时任务从主程序剥离的时候,可以交给celery执行

```python
# celery 构成  -- "生产者 消费者模型"设计模式
1. 客户端(client) 任务发送方 - 谁调用,谁实现
2. 任务队列(broker)  解耦合
3. 任务执行者(worker)  多进程\多协程
# Celery就是一个用python写的并行分布式框架, 用来 异步 处理任务.
- Celery的架构
Celery的架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。
- 消息中间件
Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成，包括，RabbitMQ,Redis,MongoDB等，这里我先去了解RabbitMQ,Redis。
- 任务执行单元
Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中

----------------------------python中使用--------------------------
# 0. 创建独立的 包; 目录结构如下:
celery_tasks
├── config.py  # 必须添加配置文件,用来配置 消息中间件
├── email  # celery用来处理: email发送任务; html静态化任务; sms短信验证码任务;
│   ├── __init__.py
│   └── tasks.py  # 每一个具体任务的客户端, 文件命名必须是 tasks
├── html  # celery用来处理: html静态化任务;
│   ├── __init__.py
│   └── tasks.py
├── __init__.py
├── main.py  # celery 执行的入口
└── sms  # celery用来处理: sms短信验证码任务;
    ├── __init__.py
    ├── tasks.py
    └── utils
        ├── __init__.py
        └── yuntongxun
            ├── CCPRestSDK.py
            ├── __init__.py
            ├── sms.py

# 具体使用:
-----------在main.py文件中-------------
1. from celery import Celery    # 安装第三方的 celery(芹菜) 包
# 2.创建 celery_app
celery_app = Celery('celery名字')  # 可以给celery取一个项目相关的名字
	- Celery第一个参数是给其设定一个名字， 
    - 第二参数我们设定一个中间人broker
# 3.添加配置文件
celery_app.config_from_object("celery_tasks.config")  # 注意路径起始位置
# 4.自动注册
celery_app.autodiscover_tasks(['celery_tasks.sms', 'celery_tasks.email', 'celery_tasks.html'])  # 注意点:1.列表; 2.路径只需要写到 包 名即可, 自动取查找包里面的 tasks.py

-------------在 具体的 tasks.py 文件中----------------
# 5.1 通过装饰器的形式,指明worker任务.
@celery_app.task(name='send_sms_code')  # 装饰器传递参数,任务的名字; task是单数
def send_sms_code(mobile, code, expires):
    pass
# 5.2 注意要配置环境,以防任务中用到 django 的环境变量,因为 celery 是可以独立执行的.

--------------------在 views.py 中----------
6.对应的视图函数中, 通过 `任务名.delay()` ,还可以传递参数来执行
sms_tasks.send_sms_code.delay(mobile, sms_code, sms_code_expires)

注: 除了 delay,还可以使用更加复杂的 apply_async() 等函数

```

![celery说明](./img_django/celery说明.png)



##### SKU  SPU 概念  

##### FastDFS 图片存储

- 原因(优势)
  - 文件名与文件内容的对应关系
  - 扩展灵活
  - 备份方便
- 背景: 淘宝开源出来的适用于电商的图片文件存储系统
- 构成角色:
  - tracker服务器   
    - 调度协调
  - storage服务器
    - 文件存储
    - 会一起安装nginx, 直接向外提供文件
  - **Tracker**: 管理集群，tracker 也可以实现集群。每个 tracker 节点地位平等。收集 Storage 集群的状态。
  - **Storage**: 实际保存文件， Storage 分为多个组，每个组之间保存的文件是不同的。每 个组内部可以有多个成员，组成员内部保存的内容是一样的，组成员的地位是一致的，没有 主从的概念。
- Django的文件存储系统
  - django默认实现了文件存储`ImageField`
  - 默认图片保存在django运行的服务器本机中
  - 对接FastDFS, 需要修改默认的文件存储系统
  - 修改文件存储的方法
    - 构造 Storage 类的子类
- 扩展阅读
  - [分布式文件系统FastDFS详解](./技术专题--FastDFS.md)

```python
# 分布式文件系统的引入 - 解决图片存储的问题
- 1.文件命名和内容重复问题:
	- 1.1 不同用户,文件名相同,但是文件内容不同;
    - 1.2 文件名不同,但是文件内容相同.
- 2.灵活 扩展 备份 问题
	- 2.0 django的admin模块中自带 Image 支持,但是不能满足需求
	- 2.1 传统的解决思路: 增加磁盘,使用磁盘阵列(磁盘阵列是由很多价格较便宜的磁盘，组合成一个容量巨大的磁盘组)
        -2.1.1 存在问题一: 没有冗余功能，如果一个磁盘（物理）损坏，则所有的数据都无法使用。
        -2.1.2 存在问题二: 磁盘的利用率较低.
    - 2.2 磁盘阵列扩展,需要停机更新.
- 3.七牛云等平台 -- 成本问题

# 解决思路: 自主搭建 FastDFS 
1. 通过 加密算法(sha1, sha256, md5等) 计算出  计算机文件指纹, 然后解决 问题一;
2. 通过 FastDFS的特点,解决问题二和问题三;

# 应用场景:
    特别适合以中小文件（建议范围：4KB  file_size 500MB）为载体的在线服务，如相册网站、视频网站等等。

# 原理细节
1.分布式系统,肯定是一个 '服务器集群' 的概念. 三个部分构成,包括两个服务器+一个客户端.
2.tracker 调度服务器;  只负责调度
3.storage 存储服务器.  上传操作,先通过tracker(返回storage的ip和port)之后,然后然后上传给storage服务器, storage 保存,并对上传的内容进行 '加密算法' 处理, 生成的 'file_id' 保证文件的唯一性,然后将 'file_id'返回.  
4.文件下载需要通过 '网络请求, http协议', 是通过 FastDFS系统自动安装的 'Nginx' 实现的, storage服务器不擅长处理.
5.关于storage,其本身是按照 '群(卷)' 来划分, 同一个卷内部的 服务器 保存相同的内容, 但是没有主从的概念,主要用来备份; 不同卷的服务器保存的内容不同,用来扩展.

# 上传文件的流程:


# 优点：
- 扩展能力: 毫无疑问，扩展能力是一个分布式文件系统最重要的特点；
- 高可用性: 在分布式文件系统中，高可用性包含两层，一是整个文件系统的可用性，二是数据的完整和一致性；
- 弹性存储: 可以根据业务需要灵活地增加或缩减数据存储以及增删存储池中的资源，而不需要中断系统运行
# 缺点：
- 系统复杂度稍高，需要更多服务器

# 安装
1. 安装起来很复杂,一般由 运维 执行.
2. 方便: 引入 Docker

# 拓展思考
1.类比处理动态数据是: web服务器--web程序--数据库
2.图片属于静态文件是: nginx服务器 -- storage服务器
```



##### Docker

- 作用
  - 以容器的技术来实现"虚拟机",提供一个独立隔离的程序运行环境.
- 使用场景
  - 通常用来进行程序的部署安装,一次构建镜像,多次创建容器运行.
- 概念
  - 仓库
    - 共有仓库    `docker  hub`
    - 私有仓库    `公司会搭建私有仓库`: 在一台服务器中运行docker官方的仓库镜像即可.
  - 镜像 :  包括运行环境的程序
  - 容器 :  在独立空间运行起来的程序(进程)和其配套的资源 
- 基本操作
  - 镜像
  - 容器

```python
# Docker 和 虚拟机(虚拟系统) 的区别
Docker -- 容器技术
虚拟机 -- 虚拟化技术
其它对比,见下图

# Docker 适合搭载的操作系统:
1. Linux(ubuntu等)
2. windows
3. mac(原因: 对网络限制的比较多, 对于需要联网操作的话会有很大限制.)

# Docker 安装与使用(部分细节)
- 权限问题, 注销重新登录
- C/S架构
```

![Docker和虚拟机对比](./img_django/container与vms对比2.png)

```python
# 使用Docker安装 FastDFS
1. 安装包含FastDFS的Docker镜像
- 1.1 通过 利用已有的FastDFS Docker镜像
- 1.2 通过 本地文件安装
2. 运行 tracker 服务器 (启动)   注:必须要先启动 tracker , 后启动 storage
3. 运行 storage 服务器 (启动)
--------------------
4.安装 python版本的FastDFS客户端
注:python版本的FastDFS客户端使用说明参考https://github.com/jefforeilly/fdfs_client-py
4.1 需要安装 github 最新的源码;
4.2 还需要安装两个 依赖 包: 'mutagen'  'requests'

5.需要修改配置文件,并将配置文件放置在 客户端文件 的目录中.
'''
base_path=FastDFS客户端存放日志文件的目录
tracker_server=运行tracker服务的机器ip:22122
'''
6.上传文件需要先创建fdfs_client.client.Fdfs_client的对象，并指明配置文件，也是有直接封装好的类,如
'''
from fdfs_client.client import Fdfs_client  
client = Fdfs_client('meiduo_mall/utils/fastdfs/client.conf')
'''
7.通过创建的客户端对象执行上传文件的方法
'''
# 指定文件路径上传
client.upload_by_filename(文件名)
 # 指定文件内容上传，注意
 # client.upload_by_buffer(文件bytes数据)
'''
------------------------------
8.自定义Django文件存储系统
(Django自带文件存储系统，但是默认文件存储在本地，在本项目中，我们需要将文件保存到FastDFS服务器上，所以需要自定义文件存储系统。)
1) 需要继承自django.core.files.storage.Storage，如
from django.core.files.storage import Storage

class FastDFSStorage(Storage):
    ...

2)支持Django不带任何参数来实例化存储类，也就是说任何设置都应该从django.conf.settings中获取
对应  __init__()方法

3)存储类中必须实现_open()和_save()方法，以及任何后续使用中可能用到的其他方法。

4)需要为存储类添加django.utils.deconstruct.deconstructible装饰器

# 代码如下
from django.conf import settings
from django.core.files.storage import Storage
from django.utils.deconstruct import deconstructible
from fdfs_client.client import Fdfs_client

@deconstructible  # 必须使用装饰器
class FastDFSStorage(Storage):
    def __init__(self, base_url=None, client_conf=None):
		"""用来添加配置文件和信息"""

    def _open(self, name, mode='rb'):  # 必须实现的方法之一
        """
        用不到打开文件，所以省略
        """
        pass

    def _save(self, name, content):   # 必须实现的方法之一
        """
        在FastDFS中保存文件
        :param name: 传入的文件名
        :param content: 文件内容
        :return: 保存到数据库中的FastDFS的文件名
        """
        client = Fdfs_client(self.client_conf)
        ret = client.upload_by_buffer(content.read())
        if ret.get("Status") != "Upload successed.":
            raise Exception("upload file failed")
        file_name = ret.get("Remote file_id")
        return file_name

    def url(self, name):
        """
        返回文件的完整URL路径
        :param name: 数据库中保存的文件名
        :return: 完整的URL
        """
        return self.base_url + name

    def exists(self, name):
        """
        判断文件是否存在，FastDFS可以自行解决文件的重名问题
        所以此处返回False，告诉Django上传的都是新文件
        :param name:  文件名
        :return: False
        """
        return False

说明: django 自动将 _save() 返回的数据(即这里是文件路径)保存到数据库,所以...
-------------------------------
9.最后 Django的 dev.py 文件中配置
# django文件存储
DEFAULT_FILE_STORAGE = 'buyfree.utils.fastdfs.fdfs_storage.FastDFSStorage'
# FastDFS
FDFS_URL = 'http://image.buyfree.site:8888/'    # 配置域名的形式,因为专门的服务器.
FDFS_CLIENT_CONF = os.path.join(BASE_DIR, 'utils/fastdfs/client.conf')
10. 在/etc/hosts中添加访问FastDFS storage服务器的域名 '127.0.0.1   image.buyfree.site'
```





##### 富文本编辑器

- 作用
  - 提供给前端的输入框支持格式编辑的功能;
  - CKEditer      `django-ckeditor` 

##### 页面静态化

- 作用: 提升服务器响应速度,减少动态接口的执行和数据库查询的次数
- 原理: 提前查询数据库,将数据渲染到模板中,写到静态的html文件中
- 说明: 页面静态化并不是全部页面都要静态化,可以一部分数据静态化,另一部分数据进行动态请求.
- 触发时机: 1.定时任务;  2.数据修改后生成
- 在django中使用定时任务完成

##### 定时任务

- django-crontab  
- ==|== 可以适当地扩展...

##### redis数据结构的设计

##### 列表页 分页

##### 搜索   全文检索

- 原因: 传统的sql查询,需要构造复杂的查询,模糊查询效率很低
- 原理: 维护索引数据(**分词**),通过将关键词在索引数据中检索,来提升查询速度.
- elasticsearch
  - java
  - rest API
- django中使用对接工具 haystack
- haystack的使用方法
  - 创建索引数据
  - 实现视图查询关键词
- 技术专题链接:  [技术专题](./技术专题--检索技术(elasticsearch).md)



##### 购物车

##### 订单保存

##### 支付宝的支付

##### xadmin

##### 权限控制

##### 数据库的读写分离

##### 部署相关

- 数据库
  - 主从分离
    - 作用: 备份, 分散数据库的压力
    - 配置方法
  - 读写分离
    - 通过程序代码分开控制数据库的读写
    - django中实现:  定义数据库的读写路由器类
      - db_for_read
      - db_for_write
- 部署
  - 静态文件处理  
    - django中需要收集静态文件
      - collectstatic
      - 收集目录  STATIC_ROOT
    - nginx提供
  - 动态程序的运行
    - uwsgi的使用方法
    - nginx转发
  - 项目的服务器结构



---

### Python中三大框架各自的应用场景?



2.Tornado 的核心是什么?

​	Tornado的核心是 ioloop 和 iostream 两个模块, 前者提供了一个高效的 I/O 事件循环, 后者则封装了 一个无阻塞的socket.

​	通过向 ioloop中添加 网络 I/O 事件, 利用 无阻塞的 socket, 再搭配 相应的 回调函数, 达到 高效异步执行.





### 性能分析工具

- timeit   -- ipython
- cProfile



---












## 七 爬虫基础及项目





## 八 项目分析方法&开发&设计模式

#### 0.业务逻辑与接口设计

- 分析要实现的业务逻辑，明确在这个业务中需要涉及到几个相关子业务，将每个子业务当做一个接口来设计。
- 分析接口的功能任务，明确接口的访问方式与返回数据：
  - 接口的请求方式，如GET 、POST 、PUT等
  - 接口的URL路径定义(rest风格)
  - 需要前端传递的数据及数据格式（如路径参数、查询字符串、请求体表单、JSON等）
  - 返回给前端的数据及数据格式

在前后端分离的应用模式中，我们作为后端开发人员设计后端接口时，可以不用考虑返回给前端数据后，前端如何处理，这是前端开发人员的工作，我们只需明确我们要保存的或者要返回的是什么数据即可。

明确上述每一点后，即可开始编写接口。

#### 1. 架构设计

- 分析可能用到的技术点
- 前后端是否分离
- 前端使用哪些框架
- 后端使用哪些框架
- 选择什么数据库
- 如何实现缓存
- 是否搭建分布式服务
- 如何管理源代码

#### 2. 数据库设计

- 数据库表的设计至关重要
- 根据项目需求，设计合适的数据库表
- 数据库表在前期如果设计不合理，后期随需求增加会变得难以维护

#### 3. 集成测试

- 在测试阶段要留意测试反馈平台的bug报告





---

1.收集所有的 小技术  ,并且去 归纳和对比(比如 异步任务耗时任务在不同项目中的解决方案), 以及去扩展  当下主流 的互联网公司的产品中应可能用到该技术的地方.



2.简历项目:  教务系统(信息化) | 内控系统(包括内控评价系统)  |  经济运营系统 | OA系统(找彭福州咨询, 夏天咨询...)



3.权限管理和认证怎么做???很具体的去阐述



4.脚本的撰写 和 os  sys  等库的常见操作...大文件的读写...

定时任务...

(运维的shell脚本... 晦涩,易忘...)



5.**DRF 中的Request和Response与Django中的HttpRequest、HttpResponse有什么区别。**

```python
REST framework 传入视图的request对象不再是Django默认的HttpRequest对象，而是REST framework提供的扩展了HttpRequest类的Request类的对象。
REST framework 提供了Parser解析器，在接收到请求后会自动根据Content-Type指明的请求数据类型（如JSON、表单等）将请求数据进行parse解析，解析为类字典对象保存到Request对象中。
Request对象的数据是自动根据前端发送数据的格式进行解析之后的结果
DRF中的Response用来构造响应对象，它可以根据请求头中的Accept（接收数据类型声明）来自动转换响应数据到对应格式， 如果前端请求中未进行Accept声明，则会采用默认方式处理响应数据。
```



6.聚合接口

- 新闻怎么获取...



7.django问题:  处理高并发



8.页面静态化 -- 解决高并发













----

==注: 上面的是我期待按照自己的思路整理的python语法 | web | 数据库 等知识.但是现在时间不允许,我只能先复习.重新按照老师笔记的思路去复习.==



# 二 python高级

## 1.Liunux介绍、命令

### 1.1操作系统

### 1.2操作系统发展史

### 1.3文件和目录

### 1.4Ubuntu图形界面入门

### 1.5Linux命令的基本使用

### 1.6Linux 终端命令格式

### 1.7Linux基本命令(一)

### 1.8Linux基本命令(二)



## 2.Linux安装软件、python开发环境



## 3.网络

3.1网络通信概述

3.2

## 4.多任务

协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。

```python
# 有耗时操作时需要
monkey.patch_all()  # 将程序中用到的耗时操作的代码，换为gevent中自己实现的模块
```

#### 简单总结

1. 进程是资源分配的单位
2. 线程是操作系统调度的单位
3. 进程切换需要的资源很最大，效率很低
4. 线程切换需要的资源一般，效率一般（当然了在不考虑GIL的情况下）
5. 协程切换任务资源很小，效率高
6. 多进程、多线程根据cpu核数不一样可能是并行的，但是协程是在一个线程中 所以是并发

#### 问题:

1.进程,线程,协程定义是啥?各自有什么特点?彼此之间有啥区别?应用场景分别是什么?

```python
# 协程的demo
from gevent import monkey
import gevent
import urllib.request

# 有耗时操作时需要
monkey.patch_all()

def my_downLoad(url):
    pass

gevent.joinall([
        gevent.spawn(my_downLoad, param),
        gevent.spawn(my_downLoad, param),
        gevent.spawn(my_downLoad, param),
])
```



2.什么是可迭代对象?什么是迭代器?什么是生成器?yield的作用?

3.锁?互斥锁?死锁?GIL锁?

```python
Python中的多线程是假的多线程?  # 因为 GIL
为什么这么说，我们先明确一个概念，全局解释器锁（GIL）global interpreter lock
Python代码的执行由Python虚拟机（解释器）来控制,同时只有一个线程在执行
对Python虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同时只有一个线程在运行。
在多线程环境中，Python虚拟机按照以下方式执行。 
- 1.设置GIL。 
- 2.切换到一个线程去执行。 
- 3.运行。 
- 4.把线程设置为睡眠状态。 
- 5.解锁GIL。 
- 6.再次重复以上步骤。
比方我有一个4核的CPU，那么这样一来，在单位时间内每个核只能跑一个线程，然后时间片轮转切换。但是Python不一样，它不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转。执行一段时间后让出，多线程在Python中只能交替执，100核只能用到1个核例如，下面的代码4核cpu只会用一个核，大概占用25%的cpu使用率。
```

**GIL和互斥锁也什么关系?**

- 没有任何关系.
- GIL 保证同一时刻只有一个进程(线程)在执行;
- 互斥锁 保证某一个任务必须全部做完才释放资源. -- 类似原子性



4.队列,进程池

5.epoll  -- 单进程单线程

```python
epoll是在  kernel 和 应用程序 空间中共享的 特殊内存空间; Nginx服务器就是基于epoll, Linux 是基于 epoll.
优势:
    - 1. 共享内存--由 操作系统和应用程序共享
    - 2. 事件通知 代替 轮询.
```

### 小总结

**I/O 多路复用的特点：**

​	通过一种机制使一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，epoll()函数就可以返回。 所以, IO多路复用，本质上不会有并发的功能，因为任何时候还是只有一个进程或线程进行工作，它之所以能提高效率是因为select\epoll 把进来的socket放到他们的 '监视' 列表里面，当任何socket有可读可写数据立马处理，那如果select\epoll 手里同时检测着很多socket， 一有动静马上返回给进程处理，总比一个一个socket过来,阻塞等待,处理高效率。

如果想了解下epoll在Linux中的实现过程可以参考：[【Linux学习】epoll详解](https://blog.csdn.net/xiajun07061225/article/details/9250579)







## 5.正则表达式

#### 注意：`(?P<name>)`和`(?P=name)`中的字母p大写

#### \num   ???

re.split(r'', html)    作用: 根据匹配进行切割.

## 6.HTTP协议、web服务器

#### HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信。

响应代码：200表示成功，3xx表示重定向，4xx表示客户端发送的请求有错误，5xx表示服务器端处理时发生了错误；

响应类型：由Content-Type指定；不要误认为是由url决定

**splitlines**  返回一个包含每行数据的列表(默认不包括换行符,可以通过参数设置,让其包括)[菜鸟教程链接](http://www.runoob.com/python3/python3-tutorial.html)

**enumerate**  依次返回一个可迭代对象的  `index` 和 `value`

**sys.argv[1]**   提取 通过命令行 输入 `python3 demo.py  params...`时, 其参数

**sys.path**  查看python解释器在 导包过程中的 搜索搜索模块时的先后顺序

```python
sys.path.append('/home/itcast/xxx')
sys.path.insert(0, '/home/itcast/xxx')  # 可以确保先搜索这个路径
```

**isdigit()** 方法检测字符串是否只由数字组成。语法: `str.isdigit()`



## 7.高级语法

```python
_x: 单前置下划线,私有化属性或方法，from somemodule import *禁止导入,类对象和子类可以访问(# 注意: 必须是类对象而不是 实例对象)
__xx：双前置下划线,避免与子类中的属性命名冲突，无法在外部直接访问(名字重整所以访问不到)
    # 可以通过  _类名__xx 访问
```



`__call__` 方法, 类中该方法可以通过 **实例化对象()**来调用.

`__str__` 方法, 可以通过 **print(实例对象)** 



`global` 关键字, 用于  在函数内部修改 (不可变类型的)全局变量 时使用.



### 封装的好处

- 从统一的'模板'处获取的  方法(功能)和属性变量(数据) 有了自己的独立空间, 使得彼此不受影响.

### 继承的好处

- 一个方法或者属性, 在父类中有了之后就可以直接在子类中使用,这样只需要定义一次即可,大大提高了代码重用率,提升开发效率.

### 多态的好处

- 调用不同子类的 **同一方法** 会**返回不同的结果**.

### super()

- 单继承 -- 没区别
- 多继承 -- 通过内置`__mro__`的方法,    (Cpython 解释器默认调用的是 C3 算法, 在新式类中实现的是广度优先, 保证 每一个父类有自己的调用顺序且只被调用一次.)

### 类方法、实例方法、静态方法

- 相同点：对于所有的方法而言，均属于类，所以 在内存中也只保存一份
- 不同点：方法调用者不同、调用方法时自动传入的参数不同。

### @property

- Python的property属性的功能是：property属性内部进行一系列的逻辑计算，最终将计算结果返回。

##### 两种实现方式:

- 装饰器 即：在方法上应用装饰器

  - 旧式类: 只有一种 **方法变属性**

  - 新式类: 通过 **取值(方法变属性)** , **修改(赋值)**, **删除方法或属性** 三类操作, 来对应 调用类方法中的`@property`方法, `@方法名.setter`方法, `@方法名.deleter`方法.

  - ```python
    class Goods:
        """python3中默认继承object类
            以python2、3执行此程序的结果不同，因为只有在python3中才有@xxx.setter  @xxx.deleter
        """
        @property
        def price(self):
            print('@property')
    
        @price.setter
        def price(self, value):
            print('@price.setter', value)
    
        @price.deleter
        def price(self):
            print('@price.deleter')
    
    obj = Goods()
    obj.price          # 自动执行 @property 修饰的 price 方法，并获取方法的返回值
    obj.price = 123    # 自动执行 @price.setter 修饰的 price 方法，并将  123 赋值给方法的参数
    del obj.price      # 自动执行 @price.deleter 修饰的 price 方法
    ```

- 类属性 即：在类中定义值为property对象的类属性

  - property方法中有个四个参数

    - 第一个参数是方法名，调用 对象.属性 时自动触发执行方法
    - 第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法
    - 第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法
    - 第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息

  - ```python
    class Foo(object):
        def get_bar(self):
           pass
    
        def set_bar(self, value): 
           pass
        def del_bar(self):
            pass
    
        BAR = property(get_bar, set_bar, del_bar, "description...")
    
    obj = Foo()
    
    obj.BAR  # 自动调用第一个参数中定义的方法：get_bar
    obj.BAR = "alex"  # 自动调用第二个参数中定义的方法：set_bar方法，并将“alex”当作参数传入
    desc = Foo.BAR.__doc__  # 自动获取第四个参数中设置的值：description...
    print(desc)
    del obj.BAR  # 自动调用第三个参数中定义的方法：del_bar方法
    ```



### 上下文管理器

  - 任何实现了 enter() 和 exit() 方法的对象都可称之为上下文管理器

  - 实现方式:

      - with方法

      - `@contextmanager` 更进一步简化了上下文管理器的实现方式。通过 yield 将函数分割成两部分，yield 之前的语句在 __enter__ 方法中执行，yield 之后的语句在 __exit__ 方法中执行。紧跟在 yield 后面的值是函数的返回值。

      - ```python
        from contextlib import contextmanager
        
        @contextmanager
        def my_open(path, mode):
            f = open(path, mode)
            yield f
            f.close()
        ```


#### 数据库





接口调试:  postman