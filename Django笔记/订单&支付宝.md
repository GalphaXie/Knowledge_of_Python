#### 订单

```python
# CreateAPIView 
查询 - 用不到  query_set
```



#### 订单表设计

- 订单表
  - 字段: `订单状态` 
- 订单商品表:



#### 订单操作思路

> - 1.创建订单记录
> - 2.创建订单商品记录
> - 3.修改商品表(减库存,加销量)
> - 4.清除购物车记录



#### 查看 drf 中 模型类 映射过来字段类型

> 借助 `python shell` 工具, 通过导入当前序列化器文件,创建指定序列化器的类(序列化器类不需要转递参数), 然后交互查看序列化器实例的结果即可. 
>
> ![1537924073283](C:\Users\XIEG2\AppData\Local\Temp\1537924073283.png)

**这是一个重要的解决问题的思路,尤其再不知道如何设置 字段选项 的时候**



#### 关于 

> `docker container ls`  - 查看当前正在运行的 coontainer
>
> `docker container ls`  - 查看当前正在运行的 coontainer
>
> 报错:
>
> ![1537964214837](C:\Users\XIEG2\AppData\Local\Temp\1537964214837.png)
>
> 错误原因: 
>
> - elasticsearch 提交订单会修改 `表结构` , 所以需要 `elasticsearch`





#### Django 自带 `事务`

> 默认: 每次操作数据库之后就会自动执行 `事务` 操作;(所以之前视图中操作数据库没有考虑这个问题)
>
> 但是,部分需求需要更大的 `原子性` 来处理 组合的 业务需求
>
> - 引入: from django.db import transaction 



#### 悲观锁 VS 乐观锁

> 背景: '超卖'问题,资源竞争
>
> `悲观锁:` 真实存在,类似 多线程资源竞争, 容易出现 **死锁** 问题, 用的少
>
> ```python
> select stock from tb_sku where id=1 for update;  # mysql 原生代码
> 
> SKU.objects.select_for_update().get(id=1)  
> # django写法, select_for_update() 链式调用
> ```
>
> 
>
> `乐观锁:`非真实存在,
>
> ```python
> update tb_sku set stock=2 where id=1 and stock=7;  # mysql 原生代码
> 
> SKU.objects.filter(id=1, stock=7).update(stock=2)  # 添加原始条件, 和受影响行数 
> ```
>
> `任务队列:`  **celery** 来实现,将并行转为串行，所有人排队下单。<u>存在问题:</u>  (必须是单进程单线程,worker必须是一个; 而且 `异步` 执行的话没法判断是否成功)

#### 本案例中使用 mysql 还需要解决的问题

**修改事务级别**

- 修改配置(可重复读->读取已提交)并重启mysql(`sudo service mysql restart`)

**数据库的(4种)事务隔离级别**

- **Serializable** 串行化，一个事务一个事务的执行
- **Repeatable read** 可重复读，无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响
- **Read committed** 读取已提交，其他事务提交了对数据的修改后，本事务就能读取到修改后的数据值
- **Read uncommitted** 读取为提交，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。

<u>注: mysql 默认的 事务隔离级别是: **可重复读**,</u>

```python
遇到一个bug:
    sudo vim mysqld.cnf 修改配置文件的时候 使用  :X 出现乱码, 加密保存
    - 解除密码的方式是:
        :set key=       # 将密码设置为 空
         退出保存的时候用 wq  ,不能用 小x  ,原因未知.
```



#### 密码知识  (面试)

 引入 : 凯撒大帝 -> 凯撒密码(X+3, 密钥容量小) ;  美国政府悬赏算法->成为 `DES`

 需求: `原始信息` -> `加密` -> `难以理解的信息` -> `解密` -> `原始信息`

 **概念**:
> 明文: 原始信息
>  密文: 难以理解的信息
>  加密: 明文 -> 密文
>  解密: 密文 -> 明文
>  加密算法: 加密/解密方式
>  密钥: 加密算法中使用到的一个信息
>  非对称算法密钥: 一对(公钥  私钥)

#####  **<u>加密算法分类(两类半)</u>**
  1.**对称加密** : 加密密钥和解密密钥一样
  2.**非对称加密** : 加密密钥和解密密钥不一样
  3.**摘要算法** : 没有密钥参数,不能还原,虽然不是加密算法,但是在信息安全上有重要作用

**应用场景**
对称加密的应用场景
  - 信息的加密

非对称加密
  - (公钥加密, 私钥解密)用于进行对称加密中的密钥的交换

  - (私钥加密, 公钥解密)用于身份的认证交换

  - (`私钥`对摘要进行加密)签名 = 摘要算法  非对称加密

摘要算法

  - 对内容的完整性进行校验,如果被篡改了或者丢失了,就不同

**常见的加密算法**
  - 1.对称加密: **`DES`(Data Encryption Standard)   `3DES`   `AES`**
  - 2.非对称加密: **`RSA`(三个人名缩写,单向函数,很大的质因数)   `ECC`(Elliptic curve cryptography)**
  - 3.摘要算法:  **`MD5(Message-Digest Algorithm)`   `sha1`  `sha256`  `sha512`  `crc`**
    - 3.1- 任意长的内容,经过摘要算法,都会得到固定长度的内容,如果原始内容发生了任何变化,结果有非常大的区别.

**CA证书**

`根CA` :  CA 也拥有一个证书（内含公钥）和私钥。网上的公众用户通过验证 CA 的签字从而信任 CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。

​	是一个证书签发机构, 将`用户身份信息`和`用户的公钥` 绑定在一起,并进行CA签名, 来供查阅...

#### 支付宝接口

引入: 开发环境   沙箱环境

`pip install python-alipay-sdk --upgrade `  : 如果没安装就安装; 如果安装了就更新到最新版本



**具体交互过程**:

> 1.用户点击`支付`
>
> 2.商城向支付宝发送请求 并携带 `参数`(签名, 订单编号, 总金额, 重定向网址, 通知网址)
>
> 3.支付宝返回给商城 `所需参数`, 商城 `拼接完整url` 返回给 用户
>
> 4.完成支付, 并重定向到 `商城`(return_url)
>
> 5.支付宝 通知 商城 支付成功. 有三种方式,支付宝推荐以后两种为准: 
>
> - 1.get请求,同步返回 参数 (用户重定向到商城)
> - 2.post请求notify_url, 返回异步通知参数 (支付宝 - > 商城)
> - 3.调用查询接口,查看交易状态. `alipay.trade.query` 

#### 配置支付宝沙箱

**生产私钥和公钥**

```python
openssl

OpenSSL> genrsa -out app_private_key.pem 2048  # 私钥RSA2 
OpenSSL> rsa -in app_private_key.pem -pubout -out app_public_key.pem # 导出公钥
OpenSSL> exit

# 2048 指 可以的长度;  第二句命令: 从私钥in 成 out 公钥(配对生成)
```

#### 老师总结的需要深入几个理解的问题

##### 1.支付宝链接地址的获取

- 1.1 得到了什么地址
- 1.2 如何防止篡改的  (hash 非对称加密)
- 1.3 到底是支付宝公钥签名 还是 商户私钥签名
  - 签名 = 私钥加密(摘要算法(明文))

##### 2.支付结果

- 2.1支付结果字典中的内容
- 2.2 到底是商户公钥签名 还是 支付宝私钥签名
  - 验证签名 = 公钥解密(签名)  ?= 摘要算法(明文)

##### 3.回放攻击

- 3.1通过 `添加时间戳` 参数 来进行加密; 以及在服务器解密验证的时候使用. 

##### 4.小技巧

- <u>url地址等  快速替换(& -> \n)来查看查询字符串的规律</u>